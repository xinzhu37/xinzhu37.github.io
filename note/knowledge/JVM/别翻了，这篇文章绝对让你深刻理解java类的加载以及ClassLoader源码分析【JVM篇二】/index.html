<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="theme-color" content="#0078E7"><meta name="author" content="xinzhu"><meta name="copyright" content="xinzhu"><meta name="generator" content="Hexo 5.4.0"><meta name="theme" content="hexo-theme-yun"><title>心竹的小镇</title><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@900&amp;display=swap" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/star-markdown-css@0.1.25/dist/yun/yun-markdown.min.css"><script src="//at.alicdn.com/t/font_1140697_dxory92pb0h.js" async></script><script src="https://cdn.jsdelivr.net/npm/scrollreveal/dist/scrollreveal.min.js" defer></script><script>document.addEventListener("DOMContentLoaded", () => {
  [".post-card",".post-content img"].forEach((target)=> {
    ScrollReveal().reveal(target);
  })
});
</script><link id="light-prism-css" rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@latest/themes/prism.css" media="(prefers-color-scheme: light)"><link id="dark-prism-css" rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@latest/themes/prism-tomorrow.css" media="(prefers-color-scheme: dark)"><link rel="icon" href="/yun.svg"><link rel="mask-icon" href="/yun.svg" color="#0078E7"><link rel="alternate icon" href="/yun.ico"><link rel="preload" href="/css/hexo-theme-yun.css" as="style"><link rel="preload" href="/js/utils.js" as="script"><link rel="preload" href="/js/hexo-theme-yun.js" as="script"><link rel="prefetch" href="/js/sidebar.js" as="script"><link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin><script id="yun-config">
    const Yun = window.Yun || {};
    window.CONFIG = {"hostname":"xinzhu37.github.io","root":"/","title":"心竹君的小站","version":"1.6.1","mode":"auto","copycode":true,"page":{"isPost":true},"i18n":{"placeholder":"搜索...","empty":"找不到您查询的内容: ${query}","hits":"找到 ${hits} 条结果","hits_time":"找到 ${hits} 条结果（用时 ${time} 毫秒）"},"anonymous_image":"https://cdn.jsdelivr.net/gh/YunYouJun/cdn/img/avatar/none.jpg","say":{"api":"https://el-bot-api.vercel.app/api/words/young"},"fireworks":{"colors":["102, 167, 221","62, 131, 225","33, 78, 194"]}};
  </script><link rel="stylesheet" href="/css/hexo-theme-yun.css"><script src="/js/utils.js"></script><script src="/js/hexo-theme-yun.js"></script><link rel="alternate" href="/atom.xml" title="心竹的小镇" type="application/atom+xml"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin><script async src="https://www.googletagmanager.com/gtag/js?id=G-1LL0D86CY9"></script><script>if (CONFIG.hostname === location.hostname) {
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-1LL0D86CY9');
}</script><script data-ad-client="ca-pub-2245427233262012" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>(function(){
  var bp = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  if (curProtocol === 'https') {
    bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
  }
  else {
    bp.src = 'http://push.zhanzhang.baidu.com/push.js';
  }
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(bp, s);
})();</script><!-- Google Tag Manager --><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src='https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);})(window,document,'script','dataLayer','GTM-M9KWR9L');</script><!-- End Google Tag Manager --><meta name="description" content="你是否真的理解java的类加载机制？点进文章的盆友不如先来做一道非常常见的面试题，如果你能做出来，可能你早已掌握并理解了java的类加载机制，若结果出乎你的意料，那就很有必要来了解了解java的类加载机制了。代码如下 package com.jvm.classloader;  class Father2&amp;#123;     public static String strFather&#x3D;&quot;Hello">
<meta property="og:type" content="article">
<meta property="og:title" content="心竹的小镇">
<meta property="og:url" content="https://xinzhu37.github.io/note/knowledge/JVM/%E5%88%AB%E7%BF%BB%E4%BA%86%EF%BC%8C%E8%BF%99%E7%AF%87%E6%96%87%E7%AB%A0%E7%BB%9D%E5%AF%B9%E8%AE%A9%E4%BD%A0%E6%B7%B1%E5%88%BB%E7%90%86%E8%A7%A3java%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E4%BB%A5%E5%8F%8AClassLoader%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E3%80%90JVM%E7%AF%87%E4%BA%8C%E3%80%91/index.html">
<meta property="og:site_name" content="心竹的小镇">
<meta property="og:description" content="你是否真的理解java的类加载机制？点进文章的盆友不如先来做一道非常常见的面试题，如果你能做出来，可能你早已掌握并理解了java的类加载机制，若结果出乎你的意料，那就很有必要来了解了解java的类加载机制了。代码如下 package com.jvm.classloader;  class Father2&amp;#123;     public static String strFather&#x3D;&quot;Hello">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://bk-zhuq.oss-cn-shanghai.aliyuncs.com/notes/se/classLoading/classLoading1.png">
<meta property="og:image" content="https://bk-zhuq.oss-cn-shanghai.aliyuncs.com/notes/se/classLoading/classLoading2.png">
<meta property="og:image" content="https://bk-zhuq.oss-cn-shanghai.aliyuncs.com/notes/se/classLoading/classLoading3.jpeg">
<meta property="og:image" content="https://bk-zhuq.oss-cn-shanghai.aliyuncs.com/notes/se/classLoading/classLoading4.jpeg">
<meta property="og:image" content="https://bk-zhuq.oss-cn-shanghai.aliyuncs.com/notes/se/classLoading/classLoading5.jpeg">
<meta property="article:published_time" content="2022-03-03T14:03:12.760Z">
<meta property="article:modified_time" content="2022-03-28T14:35:34.601Z">
<meta property="article:author" content="xinzhu">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://bk-zhuq.oss-cn-shanghai.aliyuncs.com/notes/se/classLoading/classLoading1.png"><script src="/js/ui/mode.js"></script></head><body><script defer src="https://cdn.jsdelivr.net/npm/animejs@latest"></script><script defer src="/js/ui/fireworks.js"></script><canvas class="fireworks"></canvas><div class="container"><a class="sidebar-toggle hty-icon-button" id="menu-btn"><div class="hamburger hamburger--spin" type="button"><span class="hamburger-box"><span class="hamburger-inner"></span></span></div></a><div class="sidebar-toggle sidebar-overlay"></div><aside class="sidebar"><script src="/js/sidebar.js"></script><ul class="sidebar-nav"><li class="sidebar-nav-item sidebar-nav-toc hty-icon-button sidebar-nav-active" data-target="post-toc-wrap" title="文章目录"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-list-ordered"></use></svg></li><li class="sidebar-nav-item sidebar-nav-overview hty-icon-button" data-target="site-overview-wrap" title="站点概览"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-passport-line"></use></svg></li></ul><div class="sidebar-panel" id="site-overview-wrap"><div class="site-info fix-top"><a class="site-author-avatar" href="/about/" title="xinzhu"><img width="96" loading="lazy" src="https://bk-zhuq.oss-cn-shanghai.aliyuncs.com/medias/avatar.png" alt="xinzhu"><span class="site-author-status" title="Looking for dawn.">🌑</span></a><div class="site-author-name"><a href="/about/">xinzhu</a></div><a class="site-name" href="/about/site.html">心竹的小镇</a><sub class="site-subtitle">Nostalgia for a foreign country trip</sub><div class="site-desciption">希望能成为一个有趣的人</div></div><nav class="site-state"><a class="site-state-item hty-icon-button icon-home" href="/" title="首页"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-home-4-line"></use></svg></span></a><div class="site-state-item"><a href="/archives/" title="归档"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-archive-line"></use></svg></span><span class="site-state-item-count">34</span></a></div><div class="site-state-item"><a href="/categories/" title="分类"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-folder-2-line"></use></svg></span><span class="site-state-item-count">10</span></a></div><div class="site-state-item"><a href="/tags/" title="标签"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="site-state-item-count">38</span></a></div><a class="site-state-item hty-icon-button" href="/about/#comment" title="留言板"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-clipboard-line"></use></svg></span></a></nav><hr style="margin-bottom:0.5rem"><div class="links-of-author"><a class="links-of-author-item hty-icon-button" rel="noopener" href="/atom.xml" title="RSS" target="_blank" style="color:orange"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-rss-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="tencent://AddContact/?fromId=50&amp;fromSubId=1&amp;subcmd=all&amp;uin=1148573442" title="QQ 1148573442" target="_blank" style="color:#12B7F5"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-qq-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://github.com/xinzhu37" title="GitHub" target="_blank" style="color:#6e5494"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-github-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://music.163.com/#/my/m/music/playlist?id=2038166981" title="网易云音乐" target="_blank" style="color:#C20C0C"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-netease-cloud-music-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="mailto:gfz0307@163.com" title="E-Mail" target="_blank" style="color:#8E71C1"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-mail-line"></use></svg></a></div><hr style="margin:0.5rem 1rem"><div class="links"><a class="links-item hty-icon-button" href="/links/" title="我的小伙伴们" style="color:dodgerblue"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-genderless-line"></use></svg></a></div><br><a class="links-item hty-icon-button" id="toggle-mode-btn" href="javascript:;" title="Mode" style="color: #f1cb64"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-contrast-2-line"></use></svg></a></div><div class="sidebar-panel sidebar-panel-active" id="post-toc-wrap"><div class="post-toc"><div class="post-toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%EF%BC%88%E7%B1%BB%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%89"><span class="toc-number">1.</span> <span class="toc-text">1、什么是类的加载（类初始化）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%811-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">1.0.1.</span> <span class="toc-text">1、1.类加载注意事项</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">2.</span> <span class="toc-text">2、类的生命周期</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%811-%E5%8A%A0%E8%BD%BD"><span class="toc-number">2.0.1.</span> <span class="toc-text">2、1.加载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%812-%E9%AA%8C%E8%AF%81"><span class="toc-number">2.0.2.</span> <span class="toc-text">2、2.验证</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%813-%E5%87%86%E5%A4%87%E3%80%90%E9%87%8D%E7%82%B9%E3%80%91"><span class="toc-number">2.0.3.</span> <span class="toc-text">2、3.准备【重点】</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%814-%E8%A7%A3%E6%9E%90"><span class="toc-number">2.0.4.</span> <span class="toc-text">2、4.解析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%815-%E5%88%9D%E5%A7%8B%E5%8C%96%E3%80%90%E9%87%8D%E7%82%B9%E3%80%91"><span class="toc-number">2.0.5.</span> <span class="toc-text">2、5.初始化【重点】</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%816-%E4%BD%BF%E7%94%A8"><span class="toc-number">2.0.6.</span> <span class="toc-text">2、6.使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%817-%E5%8D%B8%E8%BD%BD"><span class="toc-number">2.0.7.</span> <span class="toc-text">2、7.卸载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%818-%E7%BB%93%E6%9D%9F%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">2.0.8.</span> <span class="toc-text">2、8.结束生命周期</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B"><span class="toc-number">3.</span> <span class="toc-text">3、接口的加载过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81%E8%A7%A3%E5%BC%80%E5%BC%80%E7%AF%87%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">4.</span> <span class="toc-text">4、解开开篇的面试题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81%E7%90%86%E8%A7%A3%E9%A6%96%E6%AC%A1%E4%B8%BB%E5%8A%A8%E4%BD%BF%E7%94%A8"><span class="toc-number">5.</span> <span class="toc-text">5、理解首次主动使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-number">6.</span> <span class="toc-text">6、类加载器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7%E3%80%81%E5%85%B3%E4%BA%8E%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="toc-number">7.</span> <span class="toc-text">7、关于命名空间</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-1%E3%80%81%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%EF%BC%9F"><span class="toc-number">7.0.1.</span> <span class="toc-text">7.1、如何理解？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2%E3%80%81%E5%87%86%E5%A4%87"><span class="toc-number">7.0.2.</span> <span class="toc-text">7.2、准备</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-3%E3%80%81%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81%E6%83%85%E6%99%AF%E4%B8%80"><span class="toc-number">7.0.3.</span> <span class="toc-text">7.3、测试代码情景一</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-4%E3%80%81%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81%E6%83%85%E6%99%AF%E4%BA%8C"><span class="toc-number">7.0.4.</span> <span class="toc-text">7.4、测试代码情景二</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-5%E3%80%81%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81%E6%83%85%E6%99%AF%E4%B8%89"><span class="toc-number">7.0.5.</span> <span class="toc-text">7.5、测试代码情景三</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-6%E3%80%81%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81%E6%83%85%E6%99%AF%E5%9B%9B"><span class="toc-number">7.0.6.</span> <span class="toc-text">7.6、测试代码情景四</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-7%E3%80%81%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81%E6%83%85%E6%99%AF%E4%BA%94"><span class="toc-number">7.0.7.</span> <span class="toc-text">7.7、测试代码情景五</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8%E3%80%81JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6"><span class="toc-number">8.</span> <span class="toc-text">8、JVM类加载机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9%E3%80%81%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B"><span class="toc-number">9.</span> <span class="toc-text">9、双亲委派模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10%E3%80%81ClassLoader%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">10.</span> <span class="toc-text">10、ClassLoader源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#10-1%E3%80%81loadClass"><span class="toc-number">10.0.1.</span> <span class="toc-text">10.1、loadClass</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-2%E3%80%81findClass"><span class="toc-number">10.0.2.</span> <span class="toc-text">10.2、findClass</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-3%E3%80%81defineClass-byte-b-int-off-int-len"><span class="toc-number">10.0.3.</span> <span class="toc-text">10.3、defineClass(byte[] b, int off, int len)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-4%E3%80%81resolveClass-Classc"><span class="toc-number">10.0.4.</span> <span class="toc-text">10.4、resolveClass (Classc)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-5%E3%80%81ClassLoader%E5%B0%8F%E7%BB%93"><span class="toc-number">10.0.5.</span> <span class="toc-text">10.5、ClassLoader小结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-number">11.</span> <span class="toc-text">11、自定义类加载器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12%E3%80%81%E5%8A%A0%E8%BD%BD%E7%B1%BB%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">12.</span> <span class="toc-text">12、加载类的三种方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#12-1%E3%80%81%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9A"><span class="toc-number">12.0.1.</span> <span class="toc-text">12.1、三种方式的区别：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-2%E3%80%81%E4%B8%A4%E7%A7%8D%E5%BC%82%E5%B8%B8-exception"><span class="toc-number">12.0.2.</span> <span class="toc-text">12.2、两种异常(exception)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-3%E3%80%81%E7%90%86%E8%A7%A3Class-forName"><span class="toc-number">12.0.3.</span> <span class="toc-text">12.3、理解Class.forName</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-4%E3%80%81Class-forName%E4%B8%8EClassLoader-loadClass%E5%8C%BA%E5%88%AB"><span class="toc-number">12.0.4.</span> <span class="toc-text">12.4、Class.forName与ClassLoader.loadClass区别</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-number">13.</span> <span class="toc-text">13、总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14%E3%80%81%E7%89%B9%E5%88%AB%E6%B3%A8%E6%84%8F"><span class="toc-number">14.</span> <span class="toc-text">14、特别注意</span></a></li></ol></div></div></div></aside><main class="sidebar-translate" id="content"><div id="post"><article class="hty-card post-block" itemscope itemtype="https://schema.org/Article"><link itemprop="mainEntityOfPage" href="https://xinzhu37.github.io/note/knowledge/JVM/%E5%88%AB%E7%BF%BB%E4%BA%86%EF%BC%8C%E8%BF%99%E7%AF%87%E6%96%87%E7%AB%A0%E7%BB%9D%E5%AF%B9%E8%AE%A9%E4%BD%A0%E6%B7%B1%E5%88%BB%E7%90%86%E8%A7%A3java%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E4%BB%A5%E5%8F%8AClassLoader%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E3%80%90JVM%E7%AF%87%E4%BA%8C%E3%80%91/"><span hidden itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="name" content="xinzhu"><meta itemprop="description"></span><span hidden itemprop="publisher" itemscope itemtype="https://schema.org/Organization"><meta itemprop="name" content="心竹的小镇"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"><a class="post-edit-link" href="null_posts/note/knowledge/JVM/别翻了，这篇文章绝对让你深刻理解java类的加载以及ClassLoader源码分析【JVM篇二】.md" target="_blank" title="编辑" rel="noopener"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-edit-line"></use></svg></a></h1><div class="post-meta"><div class="post-time" style="display:inline-block"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-calendar-line"></use></svg></span> <time title="创建时间：2022-03-03 22:03:12" itemprop="dateCreated datePublished" datetime="2022-03-03T22:03:12+08:00">2022-03-03</time><span class="post-meta-divider">-</span><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-calendar-2-line"></use></svg></span> <time title="修改时间：2022-03-28 22:35:34" itemprop="dateModified" datetime="2022-03-28T22:35:34+08:00">2022-03-28</time></div><div class="post-classify"></div></div></header><section class="post-body" itemprop="articleBody"><div class="post-content markdown-body" style="--smc-primary:#0078E7;"><p>你是否真的理解java的类加载机制？点进文章的盆友不如先来做一道非常常见的面试题，如果你能做出来，可能你早已掌握并理解了java的类加载机制，若结果出乎你的意料，那就很有必要来了解了解java的类加载机制了。代码如下</p>
<pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>jvm<span class="token punctuation">.</span>classloader</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Father2</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">String</span> strFather<span class="token operator">=</span><span class="token string">"HelloJVM_Father"</span><span class="token punctuation">;</span>

    <span class="token keyword">static</span><span class="token punctuation">&#123;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Father静态代码块"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">class</span> <span class="token class-name">Son2</span> <span class="token keyword">extends</span> <span class="token class-name">Father2</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">String</span> strSon<span class="token operator">=</span><span class="token string">"HelloJVM_Son"</span><span class="token punctuation">;</span>

    <span class="token keyword">static</span><span class="token punctuation">&#123;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Son静态代码块"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">InitativeUseTest2</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>

       <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Son2</span><span class="token punctuation">.</span>strSon<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>
运行结果：
        <span class="token class-name">Father</span>静态代码块
        <span class="token class-name">Son</span>静态代码块
        <span class="token class-name">HelloJVM_Son</span></code></pre>

<p>嗯哼？其实上面程序并不是关键，可能真的难不倒各位，不妨做下面一道面试题可好？如果下面这道面试题都做对了，那没错了，这篇文章你就不用看了，真的。</p>
<pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>jvm<span class="token punctuation">.</span>classloader</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">YeYe</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">static</span> <span class="token punctuation">&#123;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"YeYe静态代码块"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">class</span> <span class="token class-name">Father</span> <span class="token keyword">extends</span> <span class="token class-name">YeYe</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">String</span> strFather<span class="token operator">=</span><span class="token string">"HelloJVM_Father"</span><span class="token punctuation">;</span>

    <span class="token keyword">static</span><span class="token punctuation">&#123;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Father静态代码块"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">class</span> <span class="token class-name">Son</span> <span class="token keyword">extends</span> <span class="token class-name">Father</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">String</span> strSon<span class="token operator">=</span><span class="token string">"HelloJVM_Son"</span><span class="token punctuation">;</span>

    <span class="token keyword">static</span><span class="token punctuation">&#123;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Son静态代码块"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">InitiativeUse</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Son</span><span class="token punctuation">.</span>strFather<span class="token punctuation">)</span><span class="token punctuation">;</span> 
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span></code></pre>

<p>各位先用“毕生所学”来猜想一下运行的结果是啥…</p>
<p>注意了…<br>注意了…<br>注意了…</p>
<pre class="language-java" data-language="java"><code class="language-java">运行结果：
    <span class="token class-name">YeYe</span>静态代码块
    <span class="token class-name">Father</span>静态代码块
    <span class="token class-name">HelloJVM_Father</span></code></pre>

<p>是对是错已经有个数了吧，我就不拆穿各位的小心思了…</p>
<p>以上的面试题其实就是典型的java类的加载问题，如果你对Java加载机制不理解，那么你可能就错了上面两道题目的。这篇文章将通过对Java类加载机制的讲解，让各位熟练理解java类的加载机制。</p>
<p>其实还是想在给出一道题，毕竟各位都已经有了前面两道题的基础了，那么请看代码：</p>
<pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>jvm<span class="token punctuation">.</span>classloader</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">YeYe</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">static</span> <span class="token punctuation">&#123;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"YeYe静态代码块"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">class</span> <span class="token class-name">Father</span> <span class="token keyword">extends</span> <span class="token class-name">YeYe</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">static</span> <span class="token class-name">String</span> strFather<span class="token operator">=</span><span class="token string">"HelloJVM_Father"</span><span class="token punctuation">;</span>

    <span class="token keyword">static</span><span class="token punctuation">&#123;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Father静态代码块"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">class</span> <span class="token class-name">Son</span> <span class="token keyword">extends</span> <span class="token class-name">Father</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">String</span> strSon<span class="token operator">=</span><span class="token string">"HelloJVM_Son"</span><span class="token punctuation">;</span>

    <span class="token keyword">static</span><span class="token punctuation">&#123;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Son静态代码块"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">InitiativeUse</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Son</span><span class="token punctuation">.</span>strFather<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span></code></pre>

<p><strong>注意了 注意了 注意了</strong></p>
<blockquote>
<p>运行结果：HelloJVM_Father</p>
</blockquote>
<p>冲动的小白童鞋看到了运行结果，果断的注销了博客账户….</p>
<h2 id="1、什么是类的加载（类初始化）"><a href="#1、什么是类的加载（类初始化）" class="headerlink" title="1、什么是类的加载（类初始化）"></a>1、什么是类的加载（类初始化）</h2><p>JVM重要的一个领域：类加载</p>
<p>当程序主动使用某个类时，如果该类还未被加载到内存中，则JVM会通过加载、连接、初始化3个步骤来对该类进行初始化。如果没有意外，JVM将会连续完成3个步骤，所以有时也把这个3个步骤统称为类加载或类初始化。</p>
<p>而类加载必然涉及类加载器，下面我们先来了解一下类的加载。</p>
<blockquote>
<p>类的加载（类初始化）：</p>
<blockquote>
<p>1、在java代码中，<strong>类型</strong>的<strong>加载</strong>、<strong>连接</strong>、与<strong>初始化</strong>过程都是在<strong>程序运行期间</strong>完成的（类从磁盘加载到内存中经历的三个阶段）【牢牢记在心里】</p>
<p>2、提供了更大的灵活性，增加了更多的可能性</p>
</blockquote>
<p>虽然上面的第一句话非常简短，但是蕴含的知识量却是巨大的！包含两个重要的概念：</p>
</blockquote>
<p>1、类型</p>
<blockquote>
<p>定义的类、接口或者枚举称为类型而不涉及对象，在类加载的过程中，是一个创建对象之前的一些信息</p>
</blockquote>
<p>2、程序运行期间</p>
<blockquote>
<p>程序运行期间完成典型例子就是动态代理，其实很多语言都是在编译期就完成了加载，也正因为这个特性给Java程序提供了更大的灵活性，增加了更多的可能性</p>
</blockquote>
<h4 id="1、1-类加载注意事项"><a href="#1、1-类加载注意事项" class="headerlink" title="1、1.类加载注意事项"></a>1、1.类加载注意事项</h4><p>1、类加载器并不需要等到某个类被 “<strong>首次主动使用</strong>” 时再加载它<del>关于首次主动使用这个重要概念下文将讲解</del><br>2、JVM规范允许类加载器在预料某个类将要被使用时就预先加载它<br>3、如果在预先加载的过程中遇到了<font color=red><code>.class</code></font>文件缺失或存在错误，类加载器必须在程序<strong>首次主动使用</strong>该类时才报告错误（<font color=red><code>LinkageError</code></font>错误）如果这个类一直没有被程序<strong>主动使用</strong>，那么类加载器就不会报告错误。</p>
<blockquote>
<p>首先给各位打个预防针：可能没有了解过JVM的童鞋可能看的很蒙，感觉全是理论的感觉，不勉强一字一句的“死看”，只要达到一种概念印象就好！等到有一定理解认识之后再回头看一遍就好很多了，毕竟学习是一种循进渐进的过程，记住没有捷径！</p>
</blockquote>
<h2 id="2、类的生命周期"><a href="#2、类的生命周期" class="headerlink" title="2、类的生命周期"></a>2、类的生命周期</h2><p><img src="https://bk-zhuq.oss-cn-shanghai.aliyuncs.com/notes/se/classLoading/classLoading1.png" alt="1" loading="lazy"></p>
<p>从上图可知，类从被加载到虚拟机内存开始，到卸载出内存为止，它的整个生命周期包括 7 个阶段，而验证、准备、解析 3 个阶段统称为连接。</p>
<p>加载、验证、准备、初始化和卸载这 5 个阶段的顺序是固定确定的，类的加载过程必须按照这种顺序开始（注意是“开始”，而不是“进行”），而解析阶段则不一定：它在某些情况下可以在初始化后再开始，这是为了支持 Java 语言的运行时绑定【也就是<strong>java的动态绑定</strong>/晚期绑定】。</p>
<h4 id="2、1-加载"><a href="#2、1-加载" class="headerlink" title="2、1.加载"></a>2、1.加载</h4><p>在上面已经提到过，加载阶段是类加载的第一个阶段！类的加载过程就是从加载阶段开始~</p>
<p>加载阶段指的是将类的<code>.class</code>文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个 <code>java.lang.Class</code>对象（JVM规范并未说明Class对象位于哪里，<strong>HotSpot虚拟机将其放在方法区中</strong>），用来封装类在方法区内的数据结构。类的加载的最终产品是位于堆区中的 <code>Class</code>对象， Class对象封装了类在方法区内的数据结构，并且向Java程序员提供了访问方法区内的数据结构的接口。</p>
<p><strong>Class对象是存放在堆区的，不是方法区，这点很多人容易犯错。</strong>类的元数据才是存在方法区的。【元数据并不是类的Class对象。Class对象是加载的最终产品，类的方法代码，变量名，方法名，访问权限，返回值等等都是在方法区的】</p>
<blockquote>
<p>JDK7创建Class实例存在堆中；因为JDK7中JavaObjectsInPerm参数值固定为false。<br>JDK8移除了永久代，转而使用元空间来实现方法区，创建的Class实例依旧在java heap（堆）中</p>
</blockquote>
<p><img src="https://bk-zhuq.oss-cn-shanghai.aliyuncs.com/notes/se/classLoading/classLoading2.png" alt="2" loading="lazy"></p>
<blockquote>
<p>编写一个新的java类时,JVM就会帮我们编译成class对象,存放在同名的.class文件中。在运行时，当需要生成这个类的对象，JVM就会检查此类是否已经装载内存中。若是没有装载，则把.class文件装入到内存中。若是装载，则根据class文件生成实例对象。</p>
</blockquote>
<p>怎么理解Class对象与new出来的对象之间的关系呢？</p>
<p>new出来的对象以<code>car</code>为例。可以把<code>car</code>的<code>Class</code>类看成具体的一个人，而<code>new car</code>则是人物映像，具体的一个人（<code>Class</code>）是唯一的，人物映像（<code>new car</code>）是多个的。镜子中的每个人物映像都是根据具体的人映造出来的，也就是说<strong>每个<code>new</code>出来的对象都是以<code>Class</code>类为模板参照出来的</strong>！为啥可以参照捏？因为Class对象提供了访问方法区内的数据结构的接口哇，上面提及过了喔！</p>
<p>总结：<br>加载阶段简单来说就是：<br><strong>.class文件（二进制数据）——&gt;读取到内存——&gt;数据放进方法区——&gt;堆中创建对应Class对象——&gt;并提供访问方法区的接口</strong></p>
<p>相对于类加载的其他阶段而言，加载阶段（准确地说，是加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，因为开发人员既可以使用系统提供的类加载器来完成加载，也可以自定义自己的类加载器来完成加载。</p>
<p>加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中，而且在Java堆中也创建一个 <code>java.lang.Class</code>类的对象，这样便可以通过该对象访问方法区中的这些数据。</p>
<p><strong>加载.calss文件的方式:</strong><br>类的加载由类加载器完成，类加载器通常由JVM提供，这些类加载器也是前面所有程序运行的基础，JVM提供的这些类加载器通常被称为系统类加载器。除此之外，开发者可以通过继承ClassLoader基类来创建自己的类加载器。<strong>通过使用不同的类加载器，可以从不同来源加载类的二进制数据</strong>，二进制数据通常有如下几种来源：</p>
<p>（1）从本地系统中直接加载<br>（2）通过网络下载.class文件<br>（3）从zip，jar等归档文件中加载.class文件<br>（4）从专用数据库中提取.class文件<br>（5）将java源文件动态编译为.class文件</p>
<h4 id="2、2-验证"><a href="#2、2-验证" class="headerlink" title="2、2.验证"></a>2、2.验证</h4><blockquote>
<p>验证：确保被加载的类的正确性。<br><strong>关于验证大可不必深入但是了解类加载机制必须要知道有这么个过程以及知道验证就是<font color=red>为了验证确保Class文件的字节流中包含的信息符合当前虚拟机的要求即可。</font></strong><br>所以下面关于验证的内容作为了解即可！</p>
</blockquote>
<p>验证是连接阶段的第一阶段，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。验证阶段大致会完成4个阶段的检验动作：</p>
<p>验证是连接阶段的第一阶段，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。验证阶段大致会完成4个阶段的检验动作：</p>
<p><strong>文件格式验证</strong>：验证字节流是否符合Class文件格式的规范；例如：是否以 <a target="_blank" rel="noopener" href="https://blog.csdn.net/zixiao217/article/details/105093754">‘0xCAFEBABE’</a>开头、主次版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型。</p>
<p><strong>元数据验证</strong>：对字节码描述的信息进行语义分析（注意：对比javac编译阶段的语义分析），以保证其描述的信息符合Java语言规范的要求；例如：这个类是否有父类，除了 <code>java.lang.Object</code>之外。</p>
<p><strong>字节码验证</strong>：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。</p>
<p><strong>符号引用验证</strong>：确保解析动作能正确执行。</p>
<p>验证阶段是非常重要的，但不是必须的，它对程序运行期没有影响，如果所引用的类经过反复验证，那么可以考虑采用 <code>-Xverifynone</code>参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。</p>
<h4 id="2、3-准备【重点】"><a href="#2、3-准备【重点】" class="headerlink" title="2、3.准备【重点】"></a>2、3.准备【重点】</h4><p>当完成字节码文件的校验之后，JVM 便会开始为类变量分配内存并初始化。准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中分配。</p>
<blockquote>
<p>这里需要注意两个关键点，即<strong>内存分配的对象</strong>以及<strong>初始化的类型</strong>。</p>
</blockquote>
<p><strong>内存分配的对象</strong>：要明白首先要知道Java 中的变量有<strong>类变量</strong>以及<strong>类成员变量</strong>两种类型，==类变量指的是被 static 修饰的变量==，而==其他所有类型的变量都属于类成员变量==。在准备阶段，JVM 只会为<strong>类变量</strong>分配内存，而不会为<strong>类成员变量</strong>分配内存。<strong>类成员变量</strong>的内存分配需要等到<strong>初始化</strong>阶段才开始（初始化阶段下面会讲到）。</p>
<p>举个例子：例如下面的代码在准备阶段，只会为 <code>LeiBianLiang</code>属性分配内存，而不会为 <code>ChenYuanBL</code>属性分配内存。</p>
<pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token class-name">LeiBianLiang</span> <span class="token operator">=</span> <span class="token number">666</span><span class="token punctuation">;</span>
<span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token class-name">ChenYuanBL</span> <span class="token operator">=</span> <span class="token string">"jvm"</span><span class="token punctuation">;</span></code></pre>

<p><strong>初始化的类型</strong>：在准备阶段，JVM 会为类变量分配内存，并为其初始化（JVM 只会为类变量分配内存，而不会为类成员变量分配内存，类成员变量自然这个时候也不能被初始化）。==但是这里的初始化指的是为变量赋予 Java 语言中该数据类型的默认值，而不是用户代码里初始化的值。==</p>
<p>例如下面的代码在准备阶段之后，<code>LeiBianLiang</code> 的值将是 0，而不是 666。</p>
<pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token class-name">LeiBianLiang</span> <span class="token operator">=</span> <span class="token number">666</span><span class="token punctuation">;</span></code></pre>

<p>注意了！！！<br>注意了！！！<br>注意了！！！</p>
<p>但如果一个变量是常量（被 <code>static final</code> 修饰）的话，那么在准备阶段，属性便会被赋予用户希望的值。例如下面的代码在准备阶段之后，<code>ChangLiang</code>的值将是 666，而不再会是 0。</p>
<pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token class-name">ChangLiang</span> <span class="token operator">=</span> <span class="token number">666</span><span class="token punctuation">;</span></code></pre>

<p>之所以 <code>static final</code> 会直接被复制，而 <code>static</code> 变量会被赋予java语言类型的默认值。其实我们稍微思考一下就能想明白了。</p>
<p>两个语句的区别是一个有 <code>final</code> 关键字修饰，另外一个没有。而 <code>final</code> 关键字在 Java 中代表不可改变的意思，意思就是说 <code>ChangLiang</code>的值一旦赋值就不会在改变了。既然一旦赋值就不会再改变，那么就必须一开始就给其赋予用户想要的值，因此被 <code>final</code> 修饰的类变量在准备阶段就会被赋予想要的值。而没有被 <code>final</code> 修饰的类变量，其可能在初始化阶段或者运行阶段发生变化，所以就没有必要在准备阶段对它赋予用户想要的值。</p>
<p>如果还不是很清晰理解final和static关键字的话建议参阅下面博主整理好的文章，希望对你有所帮助！</p>
<p>java中的Static、final、Static final各种用法</p>
<h4 id="2、4-解析"><a href="#2、4-解析" class="headerlink" title="2、4.解析"></a>2、4.解析</h4><p>当通过准备阶段之后，进入解析阶段。解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。符号引用就是一组符号来描述目标，可以是任何字面量。</p>
<p>直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。</p>
<p>==其实这个阶段对于我们来说也是几乎透明的，了解一下就好==。</p>
<h4 id="2、5-初始化【重点】"><a href="#2、5-初始化【重点】" class="headerlink" title="2、5.初始化【重点】"></a>2、5.初始化【重点】</h4><p>到了初始化阶段，用户定义的 Java 程序代码才真正开始执行。</p>
<p>Java程序对类的使用方式可分为两种:<strong>主动使用</strong>与<strong>被动使用</strong>。一般来说只有<strong>当对类的==首次主动使用==的时候才会导致类的初始化</strong>，所以<strong>主动使用</strong>又叫做<strong>类加载过程中“初始化”开始的时机</strong>。那啥是主动使用呢？类的主动使用包括以下六种【超级重点】：</p>
<blockquote>
<p>1、 创建类的实例，也就是new的方式</p>
<p>2、 访问某个类或接口的静态变量，或者对该静态变量赋值（凡是被final修饰不不不其实更准确的说是在编译器把结果放入常量池的静态字段除外）</p>
<p>3、 调用类的静态方法</p>
<p>4、 反射（如 Class.forName(“com.gx.yichun”)）</p>
<p>5、 初始化某个类的子类，则其父类也会被初始化</p>
<p>6、 Java虚拟机启动时被标明为启动类的类（ JavaTest ），还有就是Main方法的类会首先被初始化</p>
<p>最后注意一点对于静态字段，只有直接定义这个字段的类才会被初始化（执行静态代码块），这句话在继承、多态中最为明显！为了方便理解下文会陆续通过例子讲解</p>
</blockquote>
<h4 id="2、6-使用"><a href="#2、6-使用" class="headerlink" title="2、6.使用"></a>2、6.使用</h4><p>当 JVM 完成初始化阶段之后，JVM 便开始从入口方法开始执行用户的程序代码。这个使用阶段也只是了解一下就可以了。</p>
<h4 id="2、7-卸载"><a href="#2、7-卸载" class="headerlink" title="2、7.卸载"></a>2、7.卸载</h4><p>当用户程序代码执行完毕后，JVM 便开始销毁创建的 Class 对象，最后负责运行的 JVM 也退出内存。这个卸载阶段也只是了解一下就可以了。</p>
<h4 id="2、8-结束生命周期"><a href="#2、8-结束生命周期" class="headerlink" title="2、8.结束生命周期"></a>2、8.结束生命周期</h4><p>在如下几种情况下，Java虚拟机将结束生命周期</p>
<blockquote>
<p>1、 执行了 System.exit()方法</p>
<p>2、 程序正常执行结束</p>
<p>3、 程序在执行过程中遇到了异常或错误而异常终止</p>
<p>4、 由于操作系统出现错误而导致Java虚拟机进程终止</p>
</blockquote>
<h2 id="3、接口的加载过程"><a href="#3、接口的加载过程" class="headerlink" title="3、接口的加载过程"></a>3、接口的加载过程</h2><p>接口加载过程与类加载过程稍有不同。</p>
<p>==当一个类在初始化时，要求其父类全部都已经初始化过了，但是一个接口在初始化时，并不要求其父接口全部都完成了初始化，当真正用到父接口的时候才会初始化。==</p>
<h2 id="4、解开开篇的面试题"><a href="#4、解开开篇的面试题" class="headerlink" title="4、解开开篇的面试题"></a>4、解开开篇的面试题</h2><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>jvm<span class="token punctuation">.</span>classloader</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Father2</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">String</span> strFather<span class="token operator">=</span><span class="token string">"HelloJVM_Father"</span><span class="token punctuation">;</span>

    <span class="token keyword">static</span><span class="token punctuation">&#123;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Father静态代码块"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">class</span> <span class="token class-name">Son2</span> <span class="token keyword">extends</span> <span class="token class-name">Father2</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">String</span> strSon<span class="token operator">=</span><span class="token string">"HelloJVM_Son"</span><span class="token punctuation">;</span>

    <span class="token keyword">static</span><span class="token punctuation">&#123;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Son静态代码块"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">InitativeUseTest2</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>

       <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Son2</span><span class="token punctuation">.</span>strSon<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

运行结果：
        <span class="token class-name">Father</span>静态代码块
        <span class="token class-name">Son</span>静态代码块
        <span class="token class-name">HelloJVM_Son</span></code></pre>

<p>再回头看这个题，这也太简单了吧，由于<code>Son2.strSon</code>是调用了<code>Son</code>类自己的静态方法属于主动使用，所以会初始化<code>Son</code>类，又由于继承关系，类继承原则是初始化一个子类，会先去初始化其父类，所以会先去初始化父类！</p>
<p>再看开篇的第二个题</p>
<pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>jvm<span class="token punctuation">.</span>classloader</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">YeYe</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">static</span> <span class="token punctuation">&#123;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"YeYe静态代码块"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">class</span> <span class="token class-name">Father</span> <span class="token keyword">extends</span> <span class="token class-name">YeYe</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">String</span> strFather<span class="token operator">=</span><span class="token string">"HelloJVM_Father"</span><span class="token punctuation">;</span>

    <span class="token keyword">static</span><span class="token punctuation">&#123;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Father静态代码块"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">class</span> <span class="token class-name">Son</span> <span class="token keyword">extends</span> <span class="token class-name">Father</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">String</span> strSon<span class="token operator">=</span><span class="token string">"HelloJVM_Son"</span><span class="token punctuation">;</span>

    <span class="token keyword">static</span><span class="token punctuation">&#123;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Son静态代码块"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">InitiativeUse</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Son</span><span class="token punctuation">.</span>strFather<span class="token punctuation">)</span><span class="token punctuation">;</span> 
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

运行结果：
    <span class="token class-name">YeYe</span>静态代码块
    <span class="token class-name">Father</span>静态代码块
    <span class="token class-name">HelloJVM_Father</span></code></pre>

<p>这个题就稍微要注意一下，不过要是你看懂这篇文章，这个题也很简单。这个题要注意什么呢？要注意子类<code>Son</code>类没有被初始化，也就是<code>Son</code>的静态代码块没有执行！发现了咩？那我们来分析分析…</p>
<p>首先看到<code>Son.strFather</code>，你会发现是子类<code>Son</code>访问父类<code>Father</code>的静态变量<code>strFather</code>，这个时候就千万要记住我在归纳主动使用概念时特别提到过的一个注意点了：<strong>对于静态字段，只有直接定义这个字段的类才会被初始化（执行静态代码块），这句话在继承、多态中最为明显！</strong></p>
<p>嗯哼，对吧，<code>Son.strFather</code>中的静态字段是属于父类<code>Father</code>的对吧，也就是说直接定义这个字段的类是父类<code>Father</code>，所以在执行 <code>System.out.println(Son.strFather);</code> 这句代码的时候会去初始化<code>Father</code>类而不是子类<code>Son</code>！是不是一下子明白了？如果明白了就支持一下博主点个赞呗，谢谢~</p>
<p>再看开篇的第三个题</p>
<pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>jvm<span class="token punctuation">.</span>classloader</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">YeYe</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">static</span> <span class="token punctuation">&#123;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"YeYe静态代码块"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">class</span> <span class="token class-name">Father</span> <span class="token keyword">extends</span> <span class="token class-name">YeYe</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">static</span> <span class="token class-name">String</span> strFather<span class="token operator">=</span><span class="token string">"HelloJVM_Father"</span><span class="token punctuation">;</span>

    <span class="token keyword">static</span><span class="token punctuation">&#123;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Father静态代码块"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">class</span> <span class="token class-name">Son</span> <span class="token keyword">extends</span> <span class="token class-name">Father</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">String</span> strSon<span class="token operator">=</span><span class="token string">"HelloJVM_Son"</span><span class="token punctuation">;</span>

    <span class="token keyword">static</span><span class="token punctuation">&#123;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Son静态代码块"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">InitiativeUse</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Son</span><span class="token punctuation">.</span>strFather<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

运行结果：<span class="token class-name">HelloJVM_Father</span></code></pre>

<p>这个题唯一的特点就在于<code>final static</code> ！是的<code>Son.strFather</code>所对应的变量便是<code>final static</code>修饰的，依旧是在本篇文章中归纳的类的主动使用范畴第二点当中：<strong>访问某个类或接口的静态变量，或者对该静态变量赋值（凡是被final修饰不不不其实更准确的说是在编译器把结果放入常量池的静态字段除外）</strong></p>
<p>所以，这个题并不会初始化任何类，当然除了Main方法所在的类！于是仅仅执行了<code>System.out.println(Son.strFather);</code>所以仅仅打印了<code>Son.strFather</code>的字段结果<code>HelloJVM_Father</code>，嗯哼，是不是又突然明白了？如果明白了就再支持一下点个赞呗，谢谢~</p>
<p>实际上上面的题目并不能完全说明本篇文章中归纳的类的主动使用范畴第二点！这话怎么说呢？怎么理解呢？再来一个程序各位就更加明了了</p>
<pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>jvm<span class="token punctuation">.</span>classloader</span><span class="token punctuation">;</span>

<span class="token keyword">import</span> <span class="token namespace">sun<span class="token punctuation">.</span>applet<span class="token punctuation">.</span></span><span class="token class-name">Main</span><span class="token punctuation">;</span>

<span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">Random</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span>UUID<span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Test</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">static</span> <span class="token punctuation">&#123;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"static 静态代码块"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

<span class="token comment">//    public static final String str= UUID.randomUUID().toString();</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">double</span> str<span class="token operator">=</span><span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//编译期不确定</span>
<span class="token punctuation">&#125;</span>


<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FinalUUidTest</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Test</span><span class="token punctuation">.</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span></code></pre>

<p>请试想一下结果，会不会执行静态代码块里的内容呢？</p>
<p>重点来了<br>重点来了<br>重点来了<br>重点来了</p>
<p>运行结果</p>
<blockquote>
<p>static 静态代码块<br>0.7338688977344875</p>
</blockquote>
<p>上面这个程序完全说明本篇文章中归纳的类的主动使用范畴第二点当中的这句话：凡是被final修饰不不不其实更准确的说是在编译器把结果放入常量池的静态字段除外！</p>
<p>分析：==其实final不是重点，重点是编译器把结果放入常量池！当一个常量的值并非编译期可以确定的，那么这个值就不会被放到调用类的常量池中，这时在程序运行时，会导致主动使用这个常量所在的类，所以这个类会被初始化==</p>
<p>到这里，能理解完上面三个题已经很不错了，但是要想更加好好的学习java，不得不给各位再来一顿烧脑盛宴，野心不大，只是单纯的想巅覆各位对java代码的认知，当然还望大佬轻拍哈哈哈，直接上代码：</p>
<pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>jvm<span class="token punctuation">.</span>classloader</span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ClassAndObjectLnitialize</span> <span class="token punctuation">&#123;</span>

        <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"输出的打印语句"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>

      <span class="token keyword">public</span> <span class="token class-name">ClassAndObjectLnitialize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>

            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"构造方法"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"我是熊孩子我的智商="</span> <span class="token operator">+</span> <span class="token class-name">ZhiShang</span> <span class="token operator">+</span><span class="token string">",情商="</span> <span class="token operator">+</span> <span class="token class-name">QingShang</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>

        <span class="token punctuation">&#123;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"普通代码块"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>

        <span class="token keyword">int</span> <span class="token class-name">ZhiShang</span> <span class="token operator">=</span> <span class="token number">250</span><span class="token punctuation">;</span>
        <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token class-name">QingShang</span> <span class="token operator">=</span> <span class="token number">666</span><span class="token punctuation">;</span>

        <span class="token keyword">static</span>
        <span class="token punctuation">&#123;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"静态代码块"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>     

<span class="token punctuation">&#125;</span></code></pre>

<p>建议这个题不要花太多时间思考，否则看了结果你会发现自己想太多了，导致最后可能你看到结果想砸电脑哈哈哈</p>
<p>隔离运行结果专业跑龙套…</p>
<p>隔离运行结果专业跑龙套…</p>
<p>隔离运行结果专业跑龙套…</p>
<p>隔离运行结果专业跑龙套…</p>
<p>隔离运行结果专业跑龙套…</p>
<blockquote>
<p>运行结果<br>        静态代码块<br>        输出的打印语句</p>
</blockquote>
<p>怎么样，是不是没有你想的那么复杂呢？</p>
<p>下面我们来简单分析一下，首先根据上面说到的触发初始化的（主动使用）的第六点：<strong>Java虚拟机启动时被标明为启动类的类（ JavaTest ），还有就是Main方法的类会首先被初始化</strong></p>
<p>嗯哼？小白童鞋就有疑问了：不是说好有Main方法的类会被初始化的么？那怎么好多东西都没有执行捏？</p>
<p>那么类的初始化顺序到底是怎么样的呢？在我们代码中，我们只知道有一个构造方法，<strong>但实际上Java代码编译成字节码之后，最开始是没有构造方法的概念的，只有==类初始化方法== 和 ==对象初始化方法== 。</strong></p>
<p>这个时候我们就不得不深入理解了！那么这两个方法是怎么来的呢？</p>
<p><strong>类初始化方法</strong>：编译器会按照其出现顺序，收集：<strong>类变量（static变量）的赋值语句</strong>、<strong>静态代码块</strong>，最终组成<strong>类初始化方法</strong>。==类初始化方法一般在<strong>类初始化</strong>的时候执行。==</p>
<p>所以，上面的这个例子，类初始化方法就会执行下面这段代码了：</p>
<pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token class-name">QingShang</span> <span class="token operator">=</span> <span class="token number">666</span><span class="token punctuation">;</span>  <span class="token comment">//类变量（static变量）的赋值语句</span>

 <span class="token keyword">static</span>   <span class="token comment">//静态代码块</span>
  <span class="token punctuation">&#123;</span>
      <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"静态代码块"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span></code></pre>

<p>而不会执行普通赋值语句以及普通代码块了</p>
<p><strong>对象初始化方法</strong>：编译器会按照其出现顺序，收集：<strong>成员变量的赋值语句</strong>、<strong>普通代码块</strong>，最后收集<strong>构造函数</strong>的代码，最终组成<strong>对象初始化方法</strong>，值得特别注意的是，如果没有监测或者收集到构造函数的代码，则将不会执行对象初始化方法。==对象初始化方法一般在<strong>实例化类对象</strong>的时候执行。==</p>
<p>以上面这个例子，其对象初始化方法就是下面这段代码了：</p>
<pre class="language-java" data-language="java"><code class="language-java"><span class="token punctuation">&#123;</span>                        
   <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"普通代码块"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//普通代码块</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token class-name">ZhiShang</span> <span class="token operator">=</span> <span class="token number">250</span><span class="token punctuation">;</span>   <span class="token comment">//成员变量的赋值语句</span>

<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"构造方法"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//最后收集构造函数的代码</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"我是熊孩子我的智商="</span> <span class="token operator">+</span> <span class="token class-name">ZhiShang</span> <span class="token operator">+</span><span class="token string">",情商="</span> <span class="token operator">+</span> <span class="token class-name">QingShang</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>

<p>明白了类初始化方法 和 对象初始化方法 之后，我们再来看这个上面例子！是的！正如上面提到的：如果没有监测或者收集到构造函数的代码，则将不会执行对象初始化方法。上面的这个例子确实没有执行对象初始化方法。忘了吗？我们根本就没有对类<code>ClassAndObjectLnitialize</code> 进行实例化！只是单纯的写了一个输出语句。</p>
<p>如果我们给其实例化，验证一下，代码如下：</p>
<pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>jvm<span class="token punctuation">.</span>classloader</span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ClassAndObjectLnitialize</span> <span class="token punctuation">&#123;</span>

        <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">new</span> <span class="token class-name">ClassAndObjectLnitialize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"输出的打印语句"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>

      <span class="token keyword">public</span> <span class="token class-name">ClassAndObjectLnitialize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>

            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"构造方法"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
             <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"我是熊孩子我的智商="</span> <span class="token operator">+</span> <span class="token class-name">ZhiShang</span> <span class="token operator">+</span><span class="token string">",情商="</span> <span class="token operator">+</span> <span class="token class-name">QingShang</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>

        <span class="token punctuation">&#123;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"普通代码块"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>

        <span class="token keyword">int</span> <span class="token class-name">ZhiShang</span> <span class="token operator">=</span> <span class="token number">250</span><span class="token punctuation">;</span>
        <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token class-name">QingShang</span> <span class="token operator">=</span> <span class="token number">666</span><span class="token punctuation">;</span>

        <span class="token keyword">static</span>
        <span class="token punctuation">&#123;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"静态代码块"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>      
<span class="token punctuation">&#125;</span>

运行结果：
        静态代码块
        普通代码块
        构造方法
        我是熊孩子我的智商<span class="token operator">=</span><span class="token number">250</span><span class="token punctuation">,</span>情商<span class="token operator">=</span><span class="token number">666</span>
        输出的打印语句     </code></pre>

<p>到这里必须要声明一点了！我为什么要用这些面试题作为这篇文章的一部分？因为关于学习有一定的方法，你可以设想一下，如果不涉及并分析这几个面试题，你还有耐心看到这里吗？小白杠精童鞋说有。。。好的，就算有，大篇大篇的理论各位扣心自问，能掌握所有知识吗？小白杠精童鞋说说能。。。额，就算能，那你能保证光记理论一个月不遗忘吗？小白杠精童鞋说可以。。。我特么一老北京布鞋过去头给你打歪（我这暴脾气我天）。所以呢学习要带着兴趣、“目的”、“野心”！希望我这段话能对你有所帮助，哪怕是一点点…</p>
<h2 id="5、理解首次主动使用"><a href="#5、理解首次主动使用" class="headerlink" title="5、理解首次主动使用"></a>5、理解首次主动使用</h2><p>我在上面提到过Java程序对类的使用方式可分为两种:主动使用与被动使用。一般来说只有当对类的<strong>首次主动使用</strong>的时候才会导致<strong>类的初始化</strong>，其中<strong>首次</strong>关键字很重要，因此特地用一小结将其讲解！</p>
<p>怎么理解呢？老规矩看个题：</p>
<pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>jvm<span class="token punctuation">.</span>classloader</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Father6</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">static</span> <span class="token punctuation">&#123;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"父类粑粑静态代码块"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">class</span> <span class="token class-name">Son6</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
    <span class="token keyword">static</span> <span class="token punctuation">&#123;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"子类熊孩子静态代码块"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">OverallTest</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">static</span> <span class="token punctuation">&#123;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Main方法静态代码块"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token class-name">Father6</span> father6<span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"======"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

         father6<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Father6</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"======"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Father6</span><span class="token punctuation">.</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"======"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Son6</span><span class="token punctuation">.</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span></code></pre>

<p>请试想一下运行结果</p>
<blockquote>
<p>运行结果：<br>        Main方法静态代码块<br>        ======<br>        父类粑粑静态代码块<br>        ======<br>        1<br>        ======<br>        子类熊孩子静态代码块<br>        2</p>
</blockquote>
<p>分析：<br>首先根据主动使用概括的第六点：Main方法的类会首先被初始化。所以最先执行Main方法静态代码块，而 <code>Father6 father6;</code>只是声明了一个引用不会执行什么，当运行到<code>father6=new Father6();</code>的时候，看到关键字<code>new</code>并且将引用<code>father6</code>指向了<code>Father6</code>对象，说明主动使用了，所以父类<code>Father6</code>将被初始化，因此打印了：父类粑粑静态代码块 ，之后执行<code>System.out.println(Father6.a);</code>属于访问静态变量所以也是主动使用，这个时候注意了，因为在上面执行<code>father6=new Father6();</code>的时候父类已经主动使用并且初始化过一次了，这次不再是首次主动使用了，所以<code>Father6</code>不会在被初始化，自然它的静态代码块就不再执行了，所以直接打印静态变量值1，而后面的<code>System.out.println(Son6.b);</code>同样，也是只初始化自己，不会去初始化父类，只因为父类<code>Father6</code>以及不再是首次主动使用了！明白了没？如果有疑问欢迎留言，绝对第一时间回复！</p>
<h2 id="6、类加载器"><a href="#6、类加载器" class="headerlink" title="6、类加载器"></a>6、类加载器</h2><p>喔o，终于到类加载器内容了！我们之前讲的类加载都是给类加载器做的一个伏笔，<strong>在这之前讲的所有类被加载都是由类加载器来完成的</strong>，可见类加载器是多么重要。由于上面的面试题并不涉及类加载器的相关知识，所以到这里再涉及涉及类加载器的知识！</p>
<p>类加载器负责加载所有的类，其为所有被载入内存中的类生成一个<code>java.lang.Class</code>实例对象。一旦一个类被加载入JVM中，同一个类就不会被再次载入了。正如一个对象有一个唯一的标识一样，一个载入JVM的类也有一个唯一的标识。</p>
<blockquote>
<p><strong>关于唯一标识符：</strong></p>
<blockquote>
<p><strong>在Java中，一个类用其全限定类名（包括包名和类名）作为标识；</strong></p>
<p><strong>但在JVM中，一个类用其全限定类名和其类加载器作为其唯一标识。</strong></p>
</blockquote>
</blockquote>
<p>类加载器的任务是根据一个类的权限定名来读取此类的二进制字节流到JVM中，然后转换为一个与目标类对应的<code>java.lang.Class</code>对象实例，在虚拟机提供了3种类加载器，启动（Bootstrap）类加载器、扩展（Extension）类加载器、系统（System）类加载器（也称应用类加载器），如下：</p>
<p><img src="https://bk-zhuq.oss-cn-shanghai.aliyuncs.com/notes/se/classLoading/classLoading3.jpeg" alt="3" loading="lazy"></p>
<p>站在Java开发人员的角度来看，类加载器可以大致划分为以下三类：</p>
<p><strong>启动类加载器</strong>： <code>BootstrapClassLoader</code>，启动类加载器主要加载的是JVM自身需要的类，这个类加载使用C++语言实现的，是虚拟机自身的一部分，负责加载存放在 <code>JDK\jre\lib</code>(JDK代表JDK的安装目录，下同)下，或被 <code>-Xbootclasspath</code>参数指定的路径中的，并且能被虚拟机识别的类库（如<code>rt.jar</code>，所有的java.开头的类均被 <code>BootstrapClassLoader</code>加载）。启动类加载器是无法被Java程序直接引用的。==总结一句话：<strong>启动类加载器</strong>加载java运行过程中的核心类库JRE\lib\rt.jar, sunrsasign.jar, charsets.jar, jce.jar, jsse.jar, plugin.jar 以及存放在JRE\classes里的类，也就是<strong>JDK提供的类</strong>等常见的比如：Object、Stirng、List…==</p>
<p><strong>扩展类加载器</strong>：ExtensionClassLoader，该加载器由 <code>sun.misc.Launcher.ExtClassLoader</code>实现，它负责加载<code>JDK\jre\lib\ext</code>目录中，或者由 <code>java.ext.dirs</code>系统变量指定的路径中的所有类库（如javax.开头的类），开发者可以直接使用扩展类加载器。</p>
<p><strong>应用程序类加载器</strong>： ApplicationClassLoader，该类加载器由 sun.misc.Launcher.AppClassLoader来实现，它负责加载用户类路径（ClassPath）所指定的类，开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。==总结一句话：<strong>应用程序类</strong>加载器加载CLASSPATH变量指定路径下的类 即指<strong>你自已在项目工程中编写的类</strong>==</p>
<p><strong>线程上下文类加载器</strong>：除了以上列举的三种类加载器，还有一种比较特殊的类型就是线程上下文类加载器。类似<code>Thread.currentThread().getContextClassLoader()</code>获取线程上下文类加载器</p>
<p>在Java的日常应用程序开发中，类的加载几乎是由上述3种类加载器相互配合执行的，在必要时，我们还可以自定义类加载器，因为JVM自带的类加载器（<code>ClassLoader</code>）只是懂得从本地文件系统加载标准的java class文件，因此如果编写了自己的<code>ClassLoader</code>，便可以做到如下几点：</p>
<blockquote>
<p>1、在执行非置信代码之前，自动验证数字签名。</p>
<p>2、动态地创建符合用户特定需要的定制化构建类。</p>
<p>3、从特定的场所取得java class，例如数据库中和网络中。</p>
</blockquote>
<p>需要注意的是，Java虚拟机对class文件采用的是按需加载的方式，也就是说当需要使用该类时才会将它的class文件加载到内存生成class对象，而且加载某个类的class文件时，Java虚拟机默认采用的是双亲委派模式即把请求交由父类处理，它一种任务委派模式，下面将会详细讲到！</p>
<p>下面我们看一个程序：</p>
<pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>jvm<span class="token punctuation">.</span>classloaderQi</span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ClassloaderTest</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token comment">//获取ClassloaderTest类的加载器</span>
        <span class="token class-name">ClassLoader</span> classLoader<span class="token operator">=</span> <span class="token class-name">ClassloaderTest</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 

        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>classLoader<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>classLoader<span class="token punctuation">.</span><span class="token function">getParent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//获取ClassloaderTest类的父类加载器</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>classLoader<span class="token punctuation">.</span><span class="token function">getParent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getParent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span></code></pre>

<p>运行结果：</p>
<blockquote>
<p>sun.misc.Launcher$AppClassLoader@18b4aac2<br>sun.misc.Launcher$ExtClassLoader@1b6d3586<br>null</p>
</blockquote>
<p>从上面的结果可以看出，并没有获取到ExtClassLoader的父Loader，原因是Bootstrap Loader（启动类加载器）是用C++语言实现的（这里仅限于Hotspot，也就是JDK1.5之后默认的虚拟机，有很多其他的虚拟机是用Java语言实现的），找不到一个确定的返回父Loader的方式，于是就返回null。至于$符号就是内部类的含义。</p>
<h2 id="7、关于命名空间"><a href="#7、关于命名空间" class="headerlink" title="7、关于命名空间"></a>7、关于命名空间</h2><p>我觉得讲类加载器，还是很有必要知道命名空间这个概念！实际上类加载器的一个必不可少的前提就是命名空间！</p>
<blockquote>
<p>命名空间概念：</p>
<p>每个类加载器都有自己的命名空间，<strong>命名空间由该加载器及所有父加载器所加载的类组成。</strong></p>
<p>特别注意：</p>
<p>在同一个命名空间中，不会出现类的完整名字（包括类的包名）相同的两个类。</p>
<p>在不同的命名空间中，有可能会出现类的完整名字（包括类的包名）相同的两个类。<br>由子加载器加载的类能看见父加载器的类，由父亲加载器加载的类不能看见子加载器加载的类</p>
</blockquote>
<p>我们已经知道每个类只能被加载一次，其实这样说是不够准确的，怎样才算是准确的呢？那就涉及到命名空间的概念了！只有在相同的命名空间中，每个类才只能被加载一次，反过来说就是一个类在不同的命名空间中是可以被加载多次的，而被加载多次的Class对象是互相独立的！</p>
<h4 id="7-1、如何理解？"><a href="#7-1、如何理解？" class="headerlink" title="7.1、如何理解？"></a>7.1、如何理解？</h4><p>当然，直接把命名空间的概念直接抛给大家，如果没有接触过，100%是看不懂其中的含义的，我敢打包票，假一赔100万。。。那么就举出写例子让各位深刻体会一下！当然这些例子涉及自定义加载器的一些知识，建议先对自定义加载器有一定了解在看！</p>
<blockquote>
<p>例子必知前提：<br>1、 自己在idea或者eclipse中创建的工程项目中只要编译之后都会有对应的class文件成在classPath目录中<br>2、 而这些目录是由ApplicationClassLoader应用加载器加载<br>3、 我之后会将class文件放到系统桌面地址上，而这些系统地址由自定义加载器指定，所以由自定义加载器加载</p>
</blockquote>
<h4 id="7-2、准备"><a href="#7-2、准备" class="headerlink" title="7.2、准备"></a>7.2、准备</h4><p>事先编译好，然后将项目工程中的两个字节码class文件【File1和File2】拷贝到系统桌面路径上，编译main方法就会出现在项目工程（ClassPath）下，注意以下例子情况中系统桌面路径的class文件一直都存在！</p>
<p><strong>Main方法情况：</strong></p>
<blockquote>
<ul>
<li>1、创建一个自定义加载器<code>classloader2</code>，并声明桌面class文件路径，接着加载<code>File1</code></li>
<li>2、打印<code>File1</code>的加载器</li>
<li>3、<code>newInstance</code>出<code>File1</code>的实例</li>
</ul>
</blockquote>
<p><strong>File1类的方法情况：</strong></p>
<blockquote>
<p>1、<code>File1</code>的构造方法中存在一行代码：<code>new File2</code> 的<code>new</code>实例代码</p>
</blockquote>
<p><strong>File2类的方法情况：</strong></p>
<blockquote>
<p> 1、打印<code>File2</code>的加载器</p>
</blockquote>
<h4 id="7-3、测试代码情景一"><a href="#7-3、测试代码情景一" class="headerlink" title="7.3、测试代码情景一"></a>7.3、测试代码情景一</h4><p>删除<code>File1</code>、<code>File2</code>项目工程中的class文件，工程项目的两个class文件都删除（只存在系统桌面路径下的class文件）</p>
<p>结果：<code>File1</code>和<code>File2</code>的加载器都是自定义加载器</p>
<h4 id="7-4、测试代码情景二"><a href="#7-4、测试代码情景二" class="headerlink" title="7.4、测试代码情景二"></a>7.4、测试代码情景二</h4><p>只删除<code>File1</code>项目工程中的class文件</p>
<p>结果：<code>File1</code>的加载器是自定义加载器，而执行到<code>File2</code>实例的加载器是App应用加载器</p>
<h4 id="7-5、测试代码情景三"><a href="#7-5、测试代码情景三" class="headerlink" title="7.5、测试代码情景三"></a>7.5、测试代码情景三</h4><p>只删除<code>File2</code>项目工程中的class文件</p>
<p>结果：<code>File1</code>的加载器都是APP应用加载器，而执行到File2实例的时候报<code>NoClassDefFoundError</code>异常</p>
<p><strong>得出结论：加载一个类（<code>File1</code>）的时候，这个类里面调用了其他的类（<code>File2</code>）或者其他类方法的初始化代码，那么这里面的类也会试着从这个类的加载器开始向上委托加载，如果全都加载不了加载不了就报<code>NoClassDefFoundError</code>异常</strong>。</p>
<p>当然这样理解命名空间和类加载机制还是远远不够的！</p>
<p><strong>File2类中发生改变情况如下：</strong></p>
<blockquote>
<ul>
<li>1、<code>File1</code>的构造方法中存在一行<code>new File2</code>的实例这没变</li>
<li>2、在<code>File2</code>的构造方法中，打印（访问）<code>File1</code>的class文件</li>
</ul>
</blockquote>
<h4 id="7-6、测试代码情景四"><a href="#7-6、测试代码情景四" class="headerlink" title="7.6、测试代码情景四"></a>7.6、测试代码情景四</h4><p>只删除项目工程中<code>File1</code>的class文件</p>
<p>结果：<code>File1</code>的加载器都是自定义加载器，而执行到<code>File2</code>实例的加载器是App应用加载器，当运行到<code>File2</code>构造方法中的打印（访问）<code>File1</code>的class文件的时候报<code>NoClassDefFoundError</code>异常</p>
<p><strong>得出结论：父亲加载器加载的类（<code>File2</code>）不能看见子加载器加载的类（<code>File1</code>）</strong></p>
<p><strong>File1方法发生改变情况如下：</strong></p>
<blockquote>
<p>1、Main方法中<code>newInstance</code>出<code>File1</code>的实例，<code>File1</code>的构造方法中存在一行<code>new File2</code>的实例这都没变<br>2、在<code>File1</code>的构造方法中，打印<code>File2</code>的class文件</p>
</blockquote>
<h4 id="7-7、测试代码情景五"><a href="#7-7、测试代码情景五" class="headerlink" title="7.7、测试代码情景五"></a>7.7、测试代码情景五</h4><p>只删除<code>File1</code>项目工程中的class文件</p>
<p>结果：<code>File1</code>的加载器都是自定义加载器，而执行到<code>File2</code>实例的加载器是App应用加载器，当运行到<code>File1</code>构造方法中的打印<code>File2</code>的class文件的时候没问题</p>
<p><strong>得出结论：由子加载器加载的类（File1）能看见父加载器的类（File2）</strong></p>
<p>当然还要注意知道的一点的是：<strong>如果两个加载器之间没有直接或间接的父子关系，那么它们各自加载类相互不可见。</strong></p>
<h2 id="8、JVM类加载机制"><a href="#8、JVM类加载机制" class="headerlink" title="8、JVM类加载机制"></a>8、JVM类加载机制</h2><p>JVM的类加载机制主要有如下3种。</p>
<p><strong>全盘负责</strong>：当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入</p>
<p><strong>父类委托</strong>：先让父类加载器试图加载该类，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类，通俗讲就是儿子们都他么是懒猪，自己不管能不能做，就算能加载也先不干，先给自己的父亲做，一个一个往上抛，直到抛到启动类加载器也就是最顶级父类，只有父亲做不了的时候再没办法由下一个子类做，直到能某一个子类能做才做，之后的子类就直接返回，实力坑爹！</p>
<p><strong>缓存机制</strong>：缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区寻找该Class，只有缓存区不存在，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓存区。这就是为什么修改了Class后，必须重启JVM，程序的修改才会生效</p>
<h2 id="9、双亲委派模型"><a href="#9、双亲委派模型" class="headerlink" title="9、双亲委派模型"></a>9、双亲委派模型</h2><p>双亲委派模型的工作流程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。也就是实力坑爹！</p>
<p>双亲委派机制:</p>
<blockquote>
<p>1、当AppClassLoader加载一个class时，它首先不会自己去尝试加载这个类，而是把类加载请求委派给父类加载器ExtClassLoader去完成。</p>
<p>2、当 ExtClassLoader加载一个class时，它首先也不会自己去尝试加载这个类，而是把类加载请求委派给BootStrapClassLoader去完成。</p>
<p>3、如果 BootStrapClassLoader加载失败（例如在 $JAVA_HOME/jre/lib里未查找到该class），会使用<br>ExtClassLoader来尝试加载；</p>
<p>4、若ExtClassLoader也加载失败，则会使用 AppClassLoader来加载，如果<br>AppClassLoader也加载失败，则会报出异常 ClassNotFoundException。</p>
<p><img src="https://bk-zhuq.oss-cn-shanghai.aliyuncs.com/notes/se/classLoading/classLoading4.jpeg" alt="4" loading="lazy"></p>
<p>从代码层面了解几个Java中定义的类加载器及其双亲委派模式的实现，它们类图关系如下：</p>
<p><img src="https://bk-zhuq.oss-cn-shanghai.aliyuncs.com/notes/se/classLoading/classLoading5.jpeg" alt="5" loading="lazy"></p>
<p>从图可以看出顶层的类加载器是<strong>抽象类ClassLoader类</strong>，其后<strong>所有的类加载器都继承自ClassLoader（不包括启动类加载器）</strong>，为了更好理解双亲委派模型，ClassLoader源码中的loadClass(String)方法该方法加载指定名称（包括包名）的二进制类型，该方法在JDK1.2之后不再建议用户重写但用户可以直接调用该方法，<strong>loadClass()方法是ClassLoader类自己实现的，该方法中的逻辑就是双亲委派模式的实现</strong>，loadClass(String name, boolean resolve)是一个重载方法，resolve参数代表是否生成class对象的同时进行解析相关操作。源码分析如下：</p>
</blockquote>
<pre class="language-java" data-language="java"><code class="language-java"> <span class="token keyword">public</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> <span class="token function">loadClass</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ClassNotFoundException</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">return</span> <span class="token function">loadClass</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

<span class="token keyword">protected</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> <span class="token function">loadClass</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token keyword">boolean</span> resolve<span class="token punctuation">)</span>
      <span class="token keyword">throws</span> <span class="token class-name">ClassNotFoundException</span>
  <span class="token punctuation">&#123;</span>
      <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token function">getClassLoadingLock</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
          <span class="token comment">// 先从缓存查找该class对象，找到就不用重新加载</span>
          <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> c <span class="token operator">=</span> <span class="token function">findLoadedClass</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
          <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
              <span class="token keyword">long</span> t0 <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
              <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>
                  <span class="token keyword">if</span> <span class="token punctuation">(</span>parent <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                      <span class="token comment">//如果找不到，则委托给父类加载器去加载</span>
                      c <span class="token operator">=</span> parent<span class="token punctuation">.</span><span class="token function">loadClass</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                  <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
                  <span class="token comment">//如果没有父类，则委托给启动加载器去加载</span>
                      c <span class="token operator">=</span> <span class="token function">findBootstrapClassOrNull</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
                  <span class="token punctuation">&#125;</span>
              <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ClassNotFoundException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                  <span class="token comment">// ClassNotFoundException thrown if class not found</span>
                  <span class="token comment">// from the non-null parent class loader</span>
              <span class="token punctuation">&#125;</span>

              <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                  <span class="token comment">// If still not found, then invoke findClass in order</span>
                  <span class="token comment">// 如果都没有找到，则通过自定义实现的findClass去查找并加载</span>
                  c <span class="token operator">=</span> <span class="token function">findClass</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>

                  <span class="token comment">// this is the defining class loader; record the stats</span>
                  <span class="token class-name"><span class="token namespace">sun<span class="token punctuation">.</span>misc<span class="token punctuation">.</span></span>PerfCounter</span><span class="token punctuation">.</span><span class="token function">getParentDelegationTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addTime</span><span class="token punctuation">(</span>t1 <span class="token operator">-</span> t0<span class="token punctuation">)</span><span class="token punctuation">;</span>
                  <span class="token class-name"><span class="token namespace">sun<span class="token punctuation">.</span>misc<span class="token punctuation">.</span></span>PerfCounter</span><span class="token punctuation">.</span><span class="token function">getFindClassTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addElapsedTimeFrom</span><span class="token punctuation">(</span>t1<span class="token punctuation">)</span><span class="token punctuation">;</span>
                  <span class="token class-name"><span class="token namespace">sun<span class="token punctuation">.</span>misc<span class="token punctuation">.</span></span>PerfCounter</span><span class="token punctuation">.</span><span class="token function">getFindClasses</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
              <span class="token punctuation">&#125;</span>
          <span class="token punctuation">&#125;</span>
          <span class="token keyword">if</span> <span class="token punctuation">(</span>resolve<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">//是否需要在加载时进行解析</span>
              <span class="token function">resolveClass</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>
          <span class="token punctuation">&#125;</span>
          <span class="token keyword">return</span> c<span class="token punctuation">;</span>
      <span class="token punctuation">&#125;</span>
  <span class="token punctuation">&#125;</span></code></pre>

<p>既然存在这个双亲委派模型，那么就一定有着存在的意义，其意义主要是：Java类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关可以避免类的重复加载，当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次。其次是考虑到安全因素，java核心api中定义类型不会被随意替换，假设通过网络传递一个名为java.lang.Integer的类，通过双亲委托模式传递到启动类加载器，而启动类加载器在核心Java API发现这个名字的类，发现该类已被加载，并不会重新加载网络传递的过来的java.lang.Integer，而直接返回已加载过的Integer.class，这样便可以防止核心API库被随意篡改。</p>
<blockquote>
<p>双亲委派模型意义总结来讲就是：<br>1、系统类防止内存中出现多份同样的字节码<br>2、保证Java程序安全稳定运行</p>
</blockquote>
<h2 id="10、ClassLoader源码分析"><a href="#10、ClassLoader源码分析" class="headerlink" title="10、ClassLoader源码分析"></a>10、ClassLoader源码分析</h2><p>ClassLoader类是一个抽象类，<strong>所有的类加载器都继承自ClassLoader（不包括启动类加载器）</strong>，因此它显得格外重要，分析ClassLoader抽象类也是非常重要的！</p>
<p><strong>简单小结一下ClassLoader抽象类中一些概念：</strong></p>
<p>二进制概念（Binary name）：格式如下</p>
<p><img src="" alt="6" loading="lazy"></p>
<p>把二进制名字转换成文件名字，然后在文件系统中磁盘上读取其二进制文件（class文件），每一个class对象都包含了定义了这个类的classload对象，class类都是由类加载器加载的只有数组类型是有JVM根据需要动态生成。</p>
<p><strong>特别注意数组类型</strong>：</p>
<blockquote>
<p>1、 数组类的类对象不是由类加载器创建的，而是根据Java运行时的需要自动创建的。<br>2、 数组类的类加载器getClassLoader()与它的元素类型的类加载器相同;如果元素类型是基本类型，则数组类没有类加载器也就是null，而这个null不同于根类加载器返回的null，它是单纯的null。</p>
</blockquote>
<p>到这里，下面就主要分析ClassLoader抽象类中几个比较重要的方法。</p>
<h4 id="10-1、loadClass"><a href="#10-1、loadClass" class="headerlink" title="10.1、loadClass"></a>10.1、loadClass</h4><p>该方法加载指定名称（包括包名）的二进制类型，该方法在JDK1.2之后不再建议用户重写但用户可以直接调用该方法，loadClass()方法是ClassLoader类自己实现的，该方法中的逻辑就是双亲委派模式的实现，其源码如下，loadClass(String name, boolean resolve)是一个重载方法，resolve参数代表是否生成class对象的同时进行解析相关操作：</p>
<pre class="language-java" data-language="java"><code class="language-java"> <span class="token keyword">public</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> <span class="token function">loadClass</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ClassNotFoundException</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">return</span> <span class="token function">loadClass</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

<span class="token keyword">protected</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> <span class="token function">loadClass</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token keyword">boolean</span> resolve<span class="token punctuation">)</span>
      <span class="token keyword">throws</span> <span class="token class-name">ClassNotFoundException</span>
  <span class="token punctuation">&#123;</span>
      <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token function">getClassLoadingLock</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
          <span class="token comment">// 先从缓存查找该class对象，找到就不用重新加载</span>
          <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> c <span class="token operator">=</span> <span class="token function">findLoadedClass</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
          <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
              <span class="token keyword">long</span> t0 <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
              <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>
                  <span class="token keyword">if</span> <span class="token punctuation">(</span>parent <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                      <span class="token comment">//如果找不到，则委托给父类加载器去加载</span>
                      c <span class="token operator">=</span> parent<span class="token punctuation">.</span><span class="token function">loadClass</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                  <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
                  <span class="token comment">//如果没有父类，则委托给启动加载器去加载</span>
                      c <span class="token operator">=</span> <span class="token function">findBootstrapClassOrNull</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
                  <span class="token punctuation">&#125;</span>
              <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ClassNotFoundException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                  <span class="token comment">// ClassNotFoundException thrown if class not found</span>
                  <span class="token comment">// from the non-null parent class loader</span>
              <span class="token punctuation">&#125;</span>

              <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                  <span class="token comment">// If still not found, then invoke findClass in order</span>
                  <span class="token comment">// 如果都没有找到，则通过自定义实现的findClass去查找并加载</span>
                  c <span class="token operator">=</span> <span class="token function">findClass</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>

                  <span class="token comment">// this is the defining class loader; record the stats</span>
                  <span class="token class-name"><span class="token namespace">sun<span class="token punctuation">.</span>misc<span class="token punctuation">.</span></span>PerfCounter</span><span class="token punctuation">.</span><span class="token function">getParentDelegationTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addTime</span><span class="token punctuation">(</span>t1 <span class="token operator">-</span> t0<span class="token punctuation">)</span><span class="token punctuation">;</span>
                  <span class="token class-name"><span class="token namespace">sun<span class="token punctuation">.</span>misc<span class="token punctuation">.</span></span>PerfCounter</span><span class="token punctuation">.</span><span class="token function">getFindClassTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addElapsedTimeFrom</span><span class="token punctuation">(</span>t1<span class="token punctuation">)</span><span class="token punctuation">;</span>
                  <span class="token class-name"><span class="token namespace">sun<span class="token punctuation">.</span>misc<span class="token punctuation">.</span></span>PerfCounter</span><span class="token punctuation">.</span><span class="token function">getFindClasses</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
              <span class="token punctuation">&#125;</span>
          <span class="token punctuation">&#125;</span>
          <span class="token keyword">if</span> <span class="token punctuation">(</span>resolve<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">//是否需要在加载时进行解析</span>
              <span class="token function">resolveClass</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>
          <span class="token punctuation">&#125;</span>
          <span class="token keyword">return</span> c<span class="token punctuation">;</span>
      <span class="token punctuation">&#125;</span>
  <span class="token punctuation">&#125;</span></code></pre>

<p>正如loadClass方法所展示的，当类加载请求到来时，先从缓存中查找该类对象，如果存在直接返回，如果不存在则交给该类加载去的父加载器去加载，倘若没有父加载则交给顶级启动类加载器去加载，最后倘若仍没有找到，则使用findClass()方法去加载（关于findClass()稍后会进一步介绍）。从loadClass实现也可以知道如果不想重新定义加载类的规则，也没有复杂的逻辑，只想在运行时加载自己指定的类，那么我们可以直接使用this.getClass().getClassLoder.loadClass(“className”)，这样就可以直接调用ClassLoader的loadClass方法获取到class对象。</p>
<h4 id="10-2、findClass"><a href="#10-2、findClass" class="headerlink" title="10.2、findClass"></a>10.2、findClass</h4><p>在JDK1.2之前，在自定义类加载时，总会去继承ClassLoader类并重写loadClass方法，从而实现自定义的类加载类，但是在JDK1.2之后已不再建议用户去覆盖loadClass()方法，而是建议把自定义的类加载逻辑写在findClass()方法中，从前面的分析可知，findClass()方法是在loadClass()方法中被调用的，当loadClass()方法中父加载器加载失败后，则会调用自己的findClass()方法来完成类加载，这样就可以保证自定义的类加载器也符合双亲委托模式。需要注意的是ClassLoader类中并没有实现findClass()方法的具体代码逻辑，取而代之的是抛出ClassNotFoundException异常，同时应该知道的是findClass方法通常是和defineClass方法一起使用的(稍后会分析)，ClassLoader类中findClass()方法源码如下：</p>
<pre class="language-java" data-language="java"><code class="language-java"><span class="token comment">//直接抛出异常</span>
<span class="token keyword">protected</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> <span class="token function">findClass</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ClassNotFoundException</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ClassNotFoundException</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<h4 id="10-3、defineClass-byte-b-int-off-int-len"><a href="#10-3、defineClass-byte-b-int-off-int-len" class="headerlink" title="10.3、defineClass(byte[] b, int off, int len)"></a>10.3、defineClass(byte[] b, int off, int len)</h4><p>defineClass()方法是用来将byte字节流解析成JVM能够识别的Class对象(ClassLoader中已实现该方法逻辑)，通过这个方法不仅能够通过class文件实例化class对象，也可以通过其他方式实例化class对象，如通过网络接收一个类的字节码，然后转换为byte字节流创建对应的Class对象，defineClass()方法通常与findClass()方法一起使用，一般情况下，在自定义类加载器时，会直接覆盖ClassLoader的findClass()方法并编写加载规则，取得要加载类的字节码后转换成流，然后调用defineClass()方法生成类的Class对象，简单例子如下：</p>
<pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">protected</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> <span class="token function">findClass</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ClassNotFoundException</span> <span class="token punctuation">&#123;</span>
      <span class="token comment">// 获取类的字节数组</span>
      <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> classData <span class="token operator">=</span> <span class="token function">getClassData</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>  
      <span class="token keyword">if</span> <span class="token punctuation">(</span>classData <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
          <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ClassNotFoundException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
          <span class="token comment">//使用defineClass生成class对象</span>
          <span class="token keyword">return</span> <span class="token function">defineClass</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> classData<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> classData<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">&#125;</span>
  <span class="token punctuation">&#125;</span></code></pre>

<p>需要注意的是，如果直接调用defineClass()方法生成类的Class对象，这个类的Class对象并没有解析(也可以理解为链接阶段，毕竟解析是链接的最后一步)，其解析操作需要等待初始化阶段进行。</p>
<h4 id="10-4、resolveClass-Classc"><a href="#10-4、resolveClass-Classc" class="headerlink" title="10.4、resolveClass (Classc)"></a>10.4、resolveClass (Classc)</h4><p>使用该方法可以使用类的Class对象创建完成也同时被解析。前面我们说链接阶段主要是对字节码进行验证，为类变量分配内存并设置初始值同时将字节码文件中的符号引用转换为直接引用。</p>
<h4 id="10-5、ClassLoader小结"><a href="#10-5、ClassLoader小结" class="headerlink" title="10.5、ClassLoader小结"></a>10.5、ClassLoader小结</h4><p>以上上述4个方法是ClassLoader类中的比较重要的方法，也是我们可能会经常用到的方法。接看SercureClassLoader扩展了 ClassLoader，新增了几个与使用相关的代码源(对代码源的位置及其证书的验证)和权限定义类验证(主要指对class源码的访问权限)的方法，一般我们不会直接跟这个类打交道，更多是与它的子类URLClassLoader有所关联，前面说过，ClassLoader是一个抽象类，很多方法是空的没有实现，比如 findClass()、findResource()等。而URLClassLoader这个实现类为这些方法提供了具体的实现，并新增了URLClassPath类协助取得Class字节码流等功能，在编写自定义类加载器时，如果没有太过于复杂的需求，可以直接继承URLClassLoader类，这样就可以避免自己去编写findClass()方法及其获取字节码流的方式，使自定义类加载器编写更加简洁。</p>
<p>检查完父类加载器之后loadClass会去默认调用findClass方法，父类（ClassLoader）中的findClass方法主要是抛出一个异常。</p>
<p>findClass根据二进制名字找到对应的class文件，返回值为Class对象Class</p>
<p>defineClass这个方法主要是将一个字节数组转换成Class实例，会抛三个异常，但只是threws一个，因为其他两个是运行时异常。</p>
<p>loadClass方法是一个加载一个指定名字的class文件，调用findLoadedClass (String)检查类是否已经加载…如果已经加装就不再加载而是直接返回第一次加载结果 所以一个类只会加载一次</p>
<h2 id="11、自定义类加载器"><a href="#11、自定义类加载器" class="headerlink" title="11、自定义类加载器"></a>11、自定义类加载器</h2><p><strong>自定义核心目的是扩展java虚拟机的动态加载类的机制</strong>，JVM默认情况是使用双亲委托机制，虽然双亲委托机制很安全极高但是有些情况我们需要自己的一种方式加载，==比如应用是通过网络来传输 Java类的字节码，为保证安全性，这些字节码经过了加密处理，这时系统类加载器就无法对其进行加载，这样则需要自定义类加载器来实现==。因此自定义类加载器也是很有必要的。</p>
<p>自定义类加载器一般都是继承自 ClassLoader类，从上面对 loadClass方法来分析来看，我们只需要重写 findClass 方法即可。<strong>自定义加载器中点：重写findClass</strong>，下面直接看自定义类加载器代码的流程：</p>
<pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>ioc<span class="token punctuation">.</span>demo</span><span class="token punctuation">;</span>

<span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token operator">*</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>nio<span class="token punctuation">.</span>file<span class="token punctuation">.</span></span><span class="token class-name">Files</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>nio<span class="token punctuation">.</span>file<span class="token punctuation">.</span></span><span class="token class-name">Paths</span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyClassLoading</span> <span class="token keyword">extends</span> <span class="token class-name">ClassLoader</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> path<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">MyClassLoading</span><span class="token punctuation">(</span><span class="token class-name">ClassLoader</span> parent<span class="token punctuation">,</span> <span class="token class-name">String</span> path<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">super</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>path <span class="token operator">=</span> path<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token keyword">public</span> <span class="token class-name">MyClassLoading</span><span class="token punctuation">(</span><span class="token class-name">String</span> pathClass<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>path <span class="token operator">=</span> pathClass<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">protected</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> <span class="token function">findClass</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ClassNotFoundException</span> <span class="token punctuation">&#123;</span>
        <span class="token class-name">Class</span> log <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token comment">// 获取该class文件字节码数组</span>
        <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> classData <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>
            classData <span class="token operator">=</span> <span class="token class-name">Files</span><span class="token punctuation">.</span><span class="token function">readAllBytes</span><span class="token punctuation">(</span><span class="token class-name">Paths</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>classData <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
            log <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">defineClass</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> classData<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span> classData<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">return</span> log<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token keyword">private</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">getData</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token class-name">File</span> file <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>file<span class="token punctuation">.</span><span class="token function">exists</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
            <span class="token class-name">FileInputStream</span> fis <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
            <span class="token class-name">ByteArrayOutputStream</span> baos <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
            <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>
                fis <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span><span class="token punctuation">;</span>
                baos <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ByteArrayOutputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

                <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> buffer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
                <span class="token keyword">int</span> length<span class="token punctuation">;</span>
                <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>length <span class="token operator">=</span> fis<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
                    baos<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>buffer<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> length<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">&#125;</span>
            <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>
                <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>
                    <span class="token keyword">assert</span> fis <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
                    fis<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">&#125;</span>
            <span class="token punctuation">&#125;</span>
            <span class="token keyword">return</span> baos<span class="token punctuation">.</span><span class="token function">toByteArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>
</code></pre>

<pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>ioc<span class="token punctuation">.</span>demo</span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">StudyClassLoading</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test1</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"自定义测试类加载器"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>
<span class="token operator">*</span><span class="token operator">*</span>此类编译成<span class="token punctuation">.</span><span class="token keyword">class</span>文件，放到桌面，项目中src下不能存有此类（以及编译后的<span class="token punctuation">.</span><span class="token keyword">class</span>文件）<span class="token operator">*</span><span class="token operator">*</span></code></pre>

<pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>ioc<span class="token punctuation">.</span>demo</span><span class="token punctuation">;</span>

<span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span></span><span class="token class-name">InvocationTargetException</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span></span><span class="token class-name">Method</span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ClassLoaderMain</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ClassNotFoundException</span><span class="token punctuation">,</span> <span class="token class-name">NoSuchMethodException</span><span class="token punctuation">,</span> <span class="token class-name">IllegalAccessException</span><span class="token punctuation">,</span> <span class="token class-name">InstantiationException</span><span class="token punctuation">,</span> <span class="token class-name">InvocationTargetException</span> <span class="token punctuation">&#123;</span>
        <span class="token class-name">String</span> pathClass <span class="token operator">=</span> <span class="token string">"/Users/xinzhu/com/ioc/demo/StudyClassLoading.class"</span><span class="token punctuation">;</span>
        <span class="token class-name">MyClassLoading</span> myClassLoading <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyClassLoading</span><span class="token punctuation">(</span>pathClass<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 类的全称</span>
        <span class="token class-name">String</span> packageNamePath <span class="token operator">=</span> <span class="token string">"com.ioc.demo.StudyClassLoading"</span><span class="token punctuation">;</span>

        <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> aClass <span class="token operator">=</span> myClassLoading<span class="token punctuation">.</span><span class="token function">loadClass</span><span class="token punctuation">(</span>packageNamePath<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"类加载器是 = "</span> <span class="token operator">+</span> aClass<span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"类的父加载器是 = "</span> <span class="token operator">+</span> aClass<span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getParent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token class-name">Method</span> method <span class="token operator">=</span> aClass<span class="token punctuation">.</span><span class="token function">getMethod</span><span class="token punctuation">(</span><span class="token string">"test1"</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Object</span> o <span class="token operator">=</span> aClass<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        method<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>o<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token class-name">Object</span><span class="token punctuation">)</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>


    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span></code></pre>

<p>自定义类加载器的核心在于对字节码文件的获取，如果是加密的字节码则需要在该类中对文件进行解密。上面代码程序只是简单Demo，并未对class文件进行加密，因此省略了解密的过程。这里有几点需要注意：</p>
<blockquote>
<p>1、这里传递的文件名需要是类的全限定性名称，即com.ioc.demo.StudyClassLoading格式的，因为<br>defineClass 方法是按这种格式进行处理的。 </p>
<p>2、最好不要重写loadClass方法，因为这样容易破坏双亲委托模式。</p>
<p>3、这类StudyClassLoading 类本身可以被 AppClassLoader类加载，因此我们不能把/Users/xinzhu/com/ioc/demo/StudyClassLoading.class放在类路径下。否则，由于双亲委托机制的存在，会直接导致该类由AppClassLoader加载，而不会通过我们自定义类加载器来加载。</p>
</blockquote>
<h2 id="12、加载类的三种方式"><a href="#12、加载类的三种方式" class="headerlink" title="12、加载类的三种方式"></a>12、加载类的三种方式</h2><p>到这里，相信大家已经对类的加载以及加载器有一定的了解了，那么你知道吗，其实加载类常见的有三种方式，如下：</p>
<blockquote>
<p>1、静态加载，也就是通过<font color=red><code>new</code></font>关键字来创建实例对象。</p>
<p>2、动态加载，也就是通过<font color=red><code>Class.forName()</code></font>方法动态加载（反射加载类型），然后调用类的newInstance()方法实例化对象。</p>
<p>3、动态加载，通过<strong>类加载器</strong>的<font color=red><code>loadClass()</code></font>方法来加载类，然后调用类的newInstance()方法实例化对象</p>
</blockquote>
<h4 id="12-1、三种方式的区别："><a href="#12-1、三种方式的区别：" class="headerlink" title="12.1、三种方式的区别："></a>12.1、三种方式的区别：</h4><p>1、第一种和第二种方式使用的类加载器是相同的，都是当前类加载器。（this.getClass.getClassLoader）。而3由用户指定类加载器。</p>
<p>2、如果需要在当前类路径以外寻找类，则只能采用第3种方式。<strong>第3种方式加载的类与当前类分属不同的命名空间</strong>。</p>
<p>3、第一种是静态加载，而第二、三种是动态加载。</p>
<h4 id="12-2、两种异常-exception"><a href="#12-2、两种异常-exception" class="headerlink" title="12.2、两种异常(exception)"></a>12.2、两种异常(exception)</h4><p>1、静态加载的时候如果在运行环境中找不到要初始化的类,抛出的是<font color=red><code>NoClassDefFoundError</code></font>,它在JAVA的异常体系中是一个<font color=red><code>Error</code></font></p>
<p>2、动态态加载的时候如果在运行环境中找不到要初始化的类,抛出的是<font color=red><code>ClassNotFoundException</code></font>,它在JAVA的异常体系中是一个<font color=red><code>checked</code></font>异常</p>
<h4 id="12-3、理解Class-forName"><a href="#12-3、理解Class-forName" class="headerlink" title="12.3、理解Class.forName"></a>12.3、理解Class.forName</h4><p><font color=red><code>Class.forName()</code></font>是一种获取<code>Class</code>对象的方法，而且是静态方法。</p>
<blockquote>
<p><font color=red><code>Class.forName()</code></font>是一个静态方法，同样可以用来加载类，<font color=red><code>Class.forName()</code></font>返回与给定的字符串名称相关联类或接口的<font color=red><code>Class</code></font>对象。注意这是一种获取<font color=red><code>Class</code></font>对象的方法</p>
</blockquote>
<p>官方给出的API文档如下</p>
<pre class="language-java" data-language="java"><code class="language-java">publicstatic <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> <span class="token function">forName</span><span class="token punctuation">(</span><span class="token class-name">String</span> className<span class="token punctuation">)</span>

<span class="token class-name">Returns</span> the <span class="token class-name">Class</span> object associated withthe <span class="token keyword">class</span> or <span class="token keyword">interface</span> <span class="token keyword">with</span> <span class="token namespace">the</span> given string <span class="token class-name"><span class="token namespace">name<span class="token punctuation">.</span></span> Invokingthis</span> method is equivalent <span class="token keyword">to</span><span class="token operator">:</span>

<span class="token class-name">Class</span><span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span>className<span class="token punctuation">,</span><span class="token boolean">true</span><span class="token punctuation">,</span> currentLoader<span class="token punctuation">)</span>

where currentLoader denotes the definingclass loader of the current <span class="token class-name"><span class="token namespace">class<span class="token punctuation">.</span></span>

For</span> example<span class="token punctuation">,</span> thefollowing code fragment returns the runtime <span class="token class-name">Class</span> descriptor <span class="token keyword">for</span> theclass named <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span></span>Thread</span><span class="token operator">:</span>

<span class="token class-name">Class</span> t <span class="token operator">=</span><span class="token class-name">Class</span><span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"java.lang.Thread"</span><span class="token punctuation">)</span>

<span class="token class-name">A</span> call <span class="token keyword">to</span> <span class="token namespace">forName</span><span class="token punctuation">(</span><span class="token string">"X"</span><span class="token punctuation">)</span> causes theclass named <span class="token class-name">X</span> <span class="token keyword">to</span> <span class="token namespace">beinitialized<span class="token punctuation">.</span></span>

<span class="token class-name">Parameters</span><span class="token operator">:</span>

className <span class="token operator">-</span> the fully qualifiedname of the desired <span class="token class-name"><span class="token namespace">class<span class="token punctuation">.</span></span>

Returns</span><span class="token operator">:</span>

the <span class="token class-name">Class</span> object <span class="token keyword">for</span> the classwith the specified name<span class="token punctuation">.</span></code></pre>

<p>可以看出，<font color=red><code>Class.forName(className)</code></font>实际上是调用<font color=red><code>Class.forName(className,true, this.getClass().getClassLoader())</code></font>。第二个参数，是指<font color=red><code>Class</code></font>被<font color=red><code>loading</code></font>后是不是必须被初始化。可以看出，使用<font color=red><code>Class.forName（className）</code></font>加载类时则已初始化。所以<font color=red><code>Class.forName()</code></font>方法可以简单的理解为：获得字符串参数中指定的类，并初始化该类。</p>
<h4 id="12-4、Class-forName与ClassLoader-loadClass区别"><a href="#12-4、Class-forName与ClassLoader-loadClass区别" class="headerlink" title="12.4、Class.forName与ClassLoader.loadClass区别"></a>12.4、Class.forName与ClassLoader.loadClass区别</h4><blockquote>
<p>首先，我们必须先明确类加载机制的三个过程主要是：加载 –&gt; 连接 –&gt; 初始化。</p>
</blockquote>
<ul>
<li><font color=red><code>Class.forName()</code></font>：将类的.class文件加载到jvm中之外，还会对类进行解释，执行类中的static块；</li>
<li><font color=red><code>ClassLoader.loadClass()</code></font>：只干一件事情，就是将.class文件加载到jvm中，不会执行static中的内容,只有在newInstance才会去执行static块。</li>
<li><font color=red><code>Class.forName(name, initialize, loader)</code></font>：带参函数也可控制是否加载static块。并且只有调用了newInstance()方法采用调用构造函数，创建类的对象 。</li>
</ul>
<p>这个时候，我们再来看一个程序：</p>
<pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>jvm<span class="token punctuation">.</span>classloader</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Demo</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">static</span> <span class="token punctuation">&#123;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"static 静态代码块"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ClassLoaderDemo</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ClassNotFoundException</span> <span class="token punctuation">&#123;</span>
        <span class="token class-name">ClassLoader</span> classLoader<span class="token operator">=</span><span class="token class-name">ClassLoaderDemo</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//1、使用ClassLoader.loadClass()来加载类，不会执行初始化块</span>
        classLoader<span class="token punctuation">.</span><span class="token function">loadClass</span><span class="token punctuation">(</span><span class="token string">"com.jvm.classloader.Demo"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">//2、使用Class.forName()来加载类，默认会执行初始化块</span>
        <span class="token class-name">Class</span><span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"com.jvm.classloader.Demo"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">//3、使用Class.forName()来加载类，并指定ClassLoader，初始化时不执行静态块 </span>
        <span class="token class-name">Class</span><span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"com.jvm.classloader.Demo"</span><span class="token punctuation">,</span><span class="token boolean">false</span><span class="token punctuation">,</span>classLoader<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span></code></pre>

<p>记得一个一个测试！我上面的程序是一次写了三个的并且已经标明了标号1、2、3！！！各位再自个电脑上跑一遍，思路就很会清晰了！</p>
<h2 id="13、总结"><a href="#13、总结" class="headerlink" title="13、总结"></a>13、总结</h2><p><strong>类的加载、连接与初始化：</strong></p>
<blockquote>
<p>1、<strong>加载</strong>：查找并加载类的二进制数据到java虚拟机中 </p>
<p>2、 <strong>连接：</strong></p>
<blockquote>
<p><strong>验证：</strong> 确保被加载的类的正确性<br><strong>准备：</strong>为类的静态变量分配内存，并将其初始化为默认值，但是到达初始化之前类变量都没有初始化为真正的初始值（如果是被<font color=red> <code>final</code></font> 修饰的类变量，则直接会被初始成用户想要的值。）<br><strong>解析</strong>：把类中的符号引用转换为直接引用，就是在类型的常量池中寻找类、接口、字段和方法的符号引用，把这些符号引用替换成直接引用的过程</p>
</blockquote>
<p>3、 <strong>初始化</strong>：为类的静态变量赋予正确的初始值  </p>
<p>类从磁盘上加载到内存中要经历五个阶段：加载、连接、初始化、使用、卸载</p>
</blockquote>
<p><strong>Java程序对类的使用方式可分为两种</strong></p>
<blockquote>
<p>（1）<strong>主动使用</strong><br>（2）被动使用</p>
</blockquote>
<p>所有的Java虚拟机实现必须在每个类或接口被Java程序“首次主动使用”时才能初始化他们<br><strong>主动使用</strong><br>（1）创建类的实例<br>（2）访问某个类或接口的静态变量 getstatic（助记符），或者对该静态变量赋值 putstatic<br>（3）调用类的静态方法 invokestatic<br>（4）反射（Class.forName(“com.test.Test”)）<br>（5）初始化一个类的子类<br>（6）Java虚拟机启动时被标明启动类的类以及包含Main方法的类<br>（7）JDK1.7开始提供的动态语言支持（了解）</p>
<p><strong>被动使用</strong><br>除了上面七种情况外，其他使用java类的方式都被看做是对类的被动使用，都不会导致类的初始化</p>
<h2 id="14、特别注意"><a href="#14、特别注意" class="headerlink" title="14、特别注意"></a>14、特别注意</h2><p>初始化入口方法。当进入类加载的初始化阶段后，JVM 会寻找整个 main 方法入口，从而初始化 main 方法所在的整个类。当需要对一个类进行初始化时，会首先初始化类构造器（），之后初始化对象构造器（）。</p>
<p><strong>初始化类构造器</strong>：JVM 会按顺序收集类变量的赋值语句、静态代码块，最终组成类构造器由 JVM 执行。<br><strong>初始化对象构造器</strong>：JVM 会按照收集成员变量的赋值语句、普通代码块，最后收集构造方法，将它们组成对象构造器，最终由 JVM 执行。值得特别注意的是，如果没有监测或者收集到构造函数的代码，则将不会执行对象初始化方法。对象初始化方法一般在实例化类对象的时候执行。</p>
<p>如果在初始化 main 方法所在类的时候遇到了其他类的初始化，那么就先加载对应的类，加载完成之后返回。如此反复循环，最终返回 main 方法所在类。</p>
<blockquote>
<p>声明，本文的出处<code>@程序员宜春过</code>公众号</p>
</blockquote>
</div><div id="reward-container"><span class="hty-icon-button button-glow" id="reward-button" title="打赏" onclick="var qr = document.getElementById(&quot;qr&quot;); qr.style.display = (qr.style.display === &quot;none&quot;) ? &quot;block&quot; : &quot;none&quot;;"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-hand-coin-line"></use></svg></span><div id="reward-comment">我很可爱，请给我钱</div><div id="qr" style="display:none;"><div style="display:inline-block"><a target="_blank" rel="noopener" href="https://bk-zhuq.oss-cn-shanghai.aliyuncs.com/medias/reward/alipay.jpg"><img loading="lazy" src="https://bk-zhuq.oss-cn-shanghai.aliyuncs.com/medias/reward/alipay.jpg" alt="支付宝" title="支付宝"></a><div><span style="color:#00A3EE"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-alipay-line"></use></svg></span></div></div><div style="display:inline-block"><a target="_blank" rel="noopener" href="https://bk-zhuq.oss-cn-shanghai.aliyuncs.com/medias/reward/wechat.png"><img loading="lazy" src="https://bk-zhuq.oss-cn-shanghai.aliyuncs.com/medias/reward/wechat.png" alt="微信支付" title="微信支付"></a><div><span style="color:#2DC100"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-wechat-pay-line"></use></svg></span></div></div></div></div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong>xinzhu</li><li class="post-copyright-link"><strong>本文链接：</strong><a href="https://xinzhu37.github.io/note/knowledge/JVM/%E5%88%AB%E7%BF%BB%E4%BA%86%EF%BC%8C%E8%BF%99%E7%AF%87%E6%96%87%E7%AB%A0%E7%BB%9D%E5%AF%B9%E8%AE%A9%E4%BD%A0%E6%B7%B1%E5%88%BB%E7%90%86%E8%A7%A3java%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E4%BB%A5%E5%8F%8AClassLoader%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E3%80%90JVM%E7%AF%87%E4%BA%8C%E3%80%91/" title="">https://xinzhu37.github.io/note/knowledge/JVM/%E5%88%AB%E7%BF%BB%E4%BA%86%EF%BC%8C%E8%BF%99%E7%AF%87%E6%96%87%E7%AB%A0%E7%BB%9D%E5%AF%B9%E8%AE%A9%E4%BD%A0%E6%B7%B1%E5%88%BB%E7%90%86%E8%A7%A3java%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E4%BB%A5%E5%8F%8AClassLoader%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E3%80%90JVM%E7%AF%87%E4%BA%8C%E3%80%91/</a></li><li class="post-copyright-license"><strong>版权声明：</strong>本博客所有文章除特别声明外，均默认采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener" title="CC BY-NC-SA 4.0 "><svg class="icon"><use xlink:href="#icon-creative-commons-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-by-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-nc-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-sa-line"></use></svg></a> 许可协议。</li></ul></section></article><div class="post-nav"><div class="post-nav-item"><a class="post-nav-prev" href="/note/knowledge/JVM/%E5%9F%BA%E4%BA%8EJDK1.8%E7%9A%84JVM%20%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%E3%80%90JVM%E7%AF%87%E4%B8%89%E3%80%91/" rel="prev" title=""><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-left-s-line"></use></svg><span class="post-nav-text"></span></a></div><div class="post-nav-item"><a class="post-nav-next" href="/note/knowledge/JVM/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B3%BB%E5%88%97%E5%88%9D%E7%AF%87%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%AD%A6%E4%B9%A0JVM%EF%BC%9F/" rel="next" title=""><span class="post-nav-text"></span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-right-s-line"></use></svg></a></div></div></div><div class="hty-card" id="comment"><div class="comment-tooltip text-center"><span>如果您有任何关于博客内容的相关讨论，欢迎前往 <a href="https://github.com/xinzhu37/xinzhu37.github.io/issues" target="_blank">GitHub issues</a> 与我交流。</span><br></div></div></main><footer class="sidebar-translate" id="footer"><div class="copyright"><span>&copy; 2020 – 2022 </span><span class="with-love" id="animate"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-cloud-line"></use></svg></span><span class="author"> xinzhu</span></div><div class="powered"><span>由 <a href="https://hexo.io" target="_blank" rel="noopener">Hexo</a> 驱动 v5.4.0</span><span class="footer-separator">|</span><span>主题 - <a rel="noopener" href="https://github.com/YunYouJun/hexo-theme-yun" target="_blank"><span>Yun</span></a> v1.6.1</span></div><div class="live_time"><span>本博客已运行</span><span id="display_live_time"></span><span class="moe-text">(●'◡'●)</span><script>function blog_live_time() {
  setTimeout(blog_live_time, 1000);
  const start = new Date('2020-09-30T00:00:00');
  const now = new Date();
  const timeDiff = (now.getTime() - start.getTime());
  const msPerMinute = 60 * 1000;
  const msPerHour = 60 * msPerMinute;
  const msPerDay = 24 * msPerHour;
  const passDay = Math.floor(timeDiff / msPerDay);
  const passHour = Math.floor((timeDiff % msPerDay) / 60 / 60 / 1000);
  const passMinute = Math.floor((timeDiff % msPerHour) / 60 / 1000);
  const passSecond = Math.floor((timeDiff % msPerMinute) / 1000);
  display_live_time.innerHTML = " " + passDay + " 天 " + passHour + " 小时 " + passMinute + " 分 " + passSecond + " 秒";
}
blog_live_time();
</script></div></footer><a class="hty-icon-button" id="back-to-top" aria-label="back-to-top" href="#"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-up-s-line"></use></svg><svg class="progress-circle-container" viewBox="0 0 100 100"><circle class="progress-circle" id="progressCircle" cx="50" cy="50" r="48" fill="none" stroke="#0078E7" stroke-width="2" stroke-linecap="round"></circle></svg></a></div></body></html>